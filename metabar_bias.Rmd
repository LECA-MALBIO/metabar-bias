---
title: "metabar_bias"
author: "Sylvain Moinard"
date: "2023-06-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
theme_set(theme_bw())
library(tidyverse)
library(dplyr)
# library(readr)
# library(stringr)
# library(readxl)
# library(openxlsx)
# library(ROBITools2)
# library(xlsx)
# 
# library(purrr)
# 
# 
# library(egg)
# library(ggpubr)
library(ggtext)
library(glue)
# library(readr)
# library(readxl)
# 
library(ROBIFastread)

```

***Ce fichier décrit l'analyse réalisée pour l'article***

***packages ordre alpha
trier les inutiles***
robitools2/robiread -> indiquer la source***

***chunks

***vérif feuille et manuscrit si toutes les valeurs sont incluses


Voir le fichier data_processing***

données : plants info
extraction
ddpcr
sper01*3, brut et non

fig modèle : valeur de K ?? (est-ce à jour ?)

## ddPCR analysis

***Données de digital droplet PCR (ddPCR)

***virer spk

***moy -> Mean

```{r}
#***ouvrir dd

summary_dd
```

## Metabarcoding preparation 

DNA concentration in the different communities

### Uniform community (U)

```{r}
CDNA_T <- 0.5 #Total DNA concentration (ng/ul) for all plants in the T community (in sample, not in pcr mix)
C_species_ref <- CDNA_T/13 #concentration of Pt6, ng/ul

summary_dd <- summary_dd %>%
  mutate(Volume_equi = max(Cmolecules_ref)/Cmolecules_ref) %>%
  mutate(cDNA_U = C_species_ref*Volume_equi) %>%
  mutate(molecules_U = cDNA_U/CtotDNA_ref*Cmolecules_ref)
#molecules/ul in sample
```

Number of molecules in the U community

```{r commu U}
VDNA_metab <- 2 #ul
VDNA_metab * summary_dd$molecules_U
VDNA_metab * sum(summary_dd$molecules_U)
```


### "Uniform in Total DNA" Communauty (T)

Number of molecules in the T community

```{r commuT}
summary_dd <- summary_dd %>%
  mutate(molecules_T = C_species_ref/CtotDNA_ref*Cmolecules_ref)

VDNA_metab * summary_dd$molecules_T
VDNA_metab * sum(summary_dd$molecules_T)

```


### Geometric community (G)

2-fold dilution

***vérif les qtés de molécules par rapport à l'article

Number of molecules in the T community

```{r commu G}
summary_dd <- summary_dd %>%
  mutate(RankG = 13 - rank(CDNA_sample/Volume_equi) + 1,
         cDNA_G = CDNA_T/2^RankG*Volume_equi,
         molecules_G = cDNA_G/CtotDNA_ref*Cmolecules_ref)

summary_dd$molecules_G * VDNA_metab
sum(summary_dd$molecules_G) * VDNA_metab
```

Figure ***1 of the manuscript

```{r}
data_dd_fig <- dataddpcr %>% filter(Used & Sample < 100) %>%
  left_join(summary_dd %>% select(sp, species_name, RankG))

order_short <- summary_dd %>% select(sp, RankG) %>%
  arrange(-RankG) %>% pull(sp)

highlight = function(x, pat, color="black", family="") {
  ifelse(grepl(pat, x), glue("<b style='font-family:{family}; color:{color}'>{x}</b>"), x)
}

ggplot(data_dd_fig)+
  geom_point(aes(factor(sp, levels = order_short, ordered = T),
                 Concentration_std,
                 shape = as.factor(TotalDNA)))+
  geom_point(data = summary_dd,
             aes(as.factor(sp), Cmolecules_ref),
             fill = "brown3", shape = 23, size = 3)+
  ggtitle(
    "Target DNA molecules for Total DNA concentration = 6.25e-4 ng/μl")+
  labs(x = "Plant species",
       y = "Number of molecules per μl\n",
       shape = "Total DNA\nconcentration\n(ng/μl)\nin the replicate")+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
  theme(axis.text.x=element_markdown())

# ggsave(filename = "ddpcr_fig_propre.pdf",
#        dpi = 600, units = "mm",
#        width = 180, height = 120, device = "pdf")
```


## Metabarcoding

Pipeline from raw data: see data_processing file




## Analyse commu***

## Analyse taqman***

## Taqman

```{r}
endpoint1 <- read.csv2("data/SPER01_End_Point_res.csv")
endpoint1 <- endpoint1[,c("Well", "End.RFU")]

ampli1 <- read.csv2("data/SPER01_ampli_res.csv")
ampli1 <- ampli1[,-1]

cq1 <- read.csv2("data/SPER01_Cq_res.csv")
cq1 <- cq1[cq1$Fluor == "FAM",c("Well", "Fluor", "Cq")]
```

### Traitement des données brutes

Prépa

Tous les F ne sont pas de vrais négatifs... (1-2, 4-5, 7-8, 10-11)

```{r}
cinetique1 <- ampli1 %>%
  pivot_longer(!Cycle, names_to = "Well",
               values_to = "RFU")
cinetique1$Primer <- "Sper01"

cinetique1$Dilu <- match(substr(cinetique1$Well, 1, 1), LETTERS)
cinetique1$Repli <- as.integer(substr(cinetique1$Well, 2, nchar(cinetique1$Well)))

cinetique1$probe <- "Fe_1"
cinetique1[cinetique1$Repli <= 9, "probe"] <- "Cbp_1" 
cinetique1[cinetique1$Repli <= 6, "probe"] <- "CbeB_1"
cinetique1[cinetique1$Repli <= 3, "probe"] <- "CbeA_1"

cinetique1$sp <- "Fe"
cinetique1[cinetique1$Repli <= 9, "sp"] <- "Cbp" 
cinetique1[cinetique1$Repli <= 6, "sp"] <- "Cbe"
cinetique1[cinetique1$Repli <= 3, "sp"] <- "Cbe"

cinetique1 <- cinetique1 %>% filter(Dilu <= 6) %>%
  mutate(Neg = (Dilu == 6))

# View(cinetique1)
```

***vers ligne 400 dans qmetabar/taqman

```{r}
res_taqman1 <- cq1 %>% left_join(endpoint1)
res_taqman1$Primer <- "Sper01"

res_taqman1$Dilu <- match(substr(res_taqman1$Well, 1, 1), LETTERS)
res_taqman1$Repli <- as.integer(substr(res_taqman1$Well, 2, nchar(res_taqman1$Well)))

res_taqman1$probe <- "Fe_1"
res_taqman1[res_taqman1$Repli <= 9, "probe"] <- "Cbp_1" 
res_taqman1[res_taqman1$Repli <= 6, "probe"] <- "CbeB_1"
res_taqman1[res_taqman1$Repli <= 3, "probe"] <- "CbeA_1"

res_taqman1$sp <- "Fe"
res_taqman1[res_taqman1$Repli <= 9, "sp"] <- "Cbp" 
res_taqman1[res_taqman1$Repli <= 6, "sp"] <- "Cbe"
res_taqman1[res_taqman1$Repli <= 3, "sp"] <- "Cbe"

res_taqman1 <- res_taqman1 %>%
  filter(Dilu <= 6) %>% mutate(Neg = (Dilu == 6))

res_taqman1 <- res_taqman1 %>%
  left_join(taqman,
            by = c("sp" = "sp", "Dilu" = "mix"))

# View(res_taqman1)

ggplot(cinetique1 %>% filter(!Neg))+
  geom_line(aes(Cycle, RFU, group = Well, col = probe))
```



***que faire de ce texte ?

pente/lambda_eq, dosage de chaque

En partant de (1+lambda)^Cq * M0 = seuil
On fait la reglin : 
Cq = -log10(M0)/log10(1+lambda)+log10(seuil)/log10(1+lambda)

il vient :
pente = -1/log10(1+lambda)
lambda = 10^(-1/pente)-1

```{r}
ggplot(res_taqman1 %>% filter(!Neg))+
  geom_point(aes(Dilu, Cq, group = Well, col = probe))

ggplot(res_taqman1 %>% filter(!Neg))+
  geom_point(aes(copies_ul, Cq, group = Well, col = probe))+
  scale_x_log10()
```


***Calcul des lambda

```{r}
res_taqman1$slope <- NA
res_taqman1$intercept <- NA

for (s in unique(res_taqman1$probe)){
  reg <- lm(Cq ~ log10(copies),
            res_taqman1 %>%
              filter(probe == s & !Neg) %>%
              group_by(Dilu) %>%
              summarise(Cq = mean(Cq),
                        copies = Vmix_taq*copies_ul[1]))
  res_taqman1[res_taqman1$probe == s, "slope"] <- reg$coefficients[2]
  res_taqman1[
    res_taqman1$probe == s, "intercept"] <- reg$coefficients[1]
}

res_taqman1$rate <- 10^(-1/res_taqman1$slope)-1

res_taqman1$Mct <- 10^(log10(1+res_taqman1$rate)*
                         res_taqman1$intercept)

res_taqman1 %>% group_by(probe) %>%
  summarise(rate = rate[1],
            Mct = Mct[1]/1e10)

```

***remettre le calcul du tirage des 2/3 réplicats 

###*** seuil rfu pour chaque puits

```{r}
res_taqman1$RFU_Cq <- NA

for (i in 1:nrow(res_taqman1)){
  aux <- cinetique1 %>% filter(Dilu == res_taqman1[i,]$Dilu &
                      Repli == res_taqman1[i,]$Repli &
                      probe == res_taqman1[i,]$probe &
                      abs(Cycle - res_taqman1[i,]$Cq)<1)

res_taqman1[i,"RFU_Cq"] <- (aux[2,]$RFU - aux[1,]$RFU)*
  (res_taqman1[i,]$Cq-aux[1,]$Cycle)+aux[1,]$RFU
}

res_taqman1 <- res_taqman1 %>%
  mutate(K = Mct/(RFU_Cq/End.RFU))

Kapprox <- res_taqman1 %>% filter(!Neg) %>%
  group_by(sp) %>%
  summarise(K = mean(K)) %>% pull(K) %>% sum

Mct1 <- res_taqman1 %>% filter(!Neg) %>%
  group_by(sp) %>%
  summarise(Mct = mean(Mct)) %>% pull(Mct) %>% mean

```

### ***Calcul de Mseuil

A Cq : (1+lam)^Cq*M0 = Mct

A un cycle donné c : Mc = (1+lam)^c*M0

et lam = (Mct/M0)^Cq - 1

Le Mct est estimé avec des valeurs très différentes -> on ne garde pas ça.

### ***Calculs des efficacités PCR


```{r}

aux <- res_taqman1 %>% filter(!Neg) %>%
  mutate(Lambda = (Mct1/(Vmix_taq*copies_ul))^(1/Cq)-1)

ggplot(aux)+
  geom_point(aes(probe, Lambda, col = factor(Dilu)))

aux %>% group_by(probe) %>% summarise(Lambda = mean(Lambda))
aux %>% group_by(sp) %>% summarise(Lambda = mean(Lambda))

lam <- aux %>% group_by(sp) %>%
  summarise(efficiency = mean(Lambda))

res_taqman1 <- res_taqman1 %>% left_join(lam)

```



***Proportions finales métabarcoding U

***l'insérer d'une manière ou d'une autre, mais plutôt dans les données de métabar

0.324197  0.425167  0.250635


### End.RFU Normalisé -> correction des Cq

***correc Cbe : à voir comment le formuler...

```{r}
x <- res_taqman1 %>% filter(sp == "Cbe" & Dilu < 6) %>%
  group_by(probe, Dilu) %>%
  summarise(end.rfu = mean(End.RFU), Cq = mean(Cq))

correcCbe <- x %>% group_by(Dilu, probe) %>%
  summarise(end.rfu = mean(end.rfu)) %>%
  pivot_wider(names_from = probe, values_from = end.rfu) %>%
  mutate(correc = CbeA_1/CbeB_1)

#Normaliser les amplitudes de CbeB de sorte à équivaloir à CbeA***

y <- cinetique1 %>% filter(sp == "Cbe" & !Neg) %>% left_join(correcCbe) %>%
  mutate(RFUbis = ifelse(probe == "CbeB_1", RFU*correc, RFU))

ggplot(y)+
  geom_line(aes(Cycle, RFU, col = probe, group = Well, linetype = factor(Dilu)))

ggplot(y)+
  geom_line(aes(Cycle, RFUbis, col = probe, group = Well, linetype = factor(Dilu)))

z <- res_taqman1 %>% filter(sp == "Cbe" & !Neg)

z$RFU_Cq <- NA
for (i in 1:nrow(z)){
  a <- cinetique1 %>% filter(Dilu == z[i,]$Dilu &
                      Repli == z[i,]$Repli &
                      probe == z[i,]$probe &
                      abs(Cycle - z[i,]$Cq)<1)

z[i,"RFU_Cq"] <- (a[2,]$RFU - a[1,]$RFU)*
  (z[i,]$Cq-a[1,]$Cycle)+a[1,]$RFU
}

seuil_Cq <- mean(z$RFU_Cq)

fCq <- function(ampli){
  c2 <- which(ampli >= seuil_Cq)[1]
  c1 <- c2-1
  Cq <- (seuil_Cq - ampli[c1]+(ampli[c2] - ampli[c1])*c1)/
    (ampli[c2] - ampli[c1])
  Cq
}

res <- NULL
for (p in unique(y$Well)){
  res <- rbind(res,
               data.frame(Well = p,
                          probe = y[y$Well == p,]$probe[1],
                          Cq = fCq(y[y$Well == p,]$RFU),
                          Cqbis = fCq(y[y$Well == p,]$RFUbis)))
}

res
z %>% select(probe,Cq, Well)

ggplot(res_taqman1 %>% filter(!Neg & sp == "Cbe"))+
  geom_point(aes(Dilu, Cq, col = probe))
```



***biais cq versus métabarcoding


```{r}
qmet1 <- df_Sper01_targetU %>%
  filter(species_name %in% c("Capsella_bursa-pastoris",
                             "Carpinus_betulus",
                             "Fraxinus_excelsior") &
           !NegControl)

ggplot(qmet1)+
  geom_boxplot(aes(species_name,
                   prop_nospk, fill = factor(Spike_level)))+
  theme(axis.text.x = element_text(angle = 90))+
  labs(fill = "Spk_lvl")
                   
qmet1 %>% group_by(species_name) %>% summarise(prop = mean(prop_nospk)) %>% mutate(prop = prop/sum(prop))

res_taqman1 %>% filter(Dilu == 3) %>% group_by(sp) %>%
  summarise(prop = mean(frac23))

```




## Simulateur***

***Cette section ajuste les modèles de PCR étudiés à des données de qPCR (SybreGreen) d'un échantillon de Capsella bursa-pastoris.

***changer nom des fichiers


***Définition des modèles PCR et des paramètres

```{r pcr models}

K <- 7.568e12 #***d'où ça sort ?
ncycles <- 60
low_cycle <- 20
high_cycle <- 50

#***commenter, changer noms de variables...

amplif <- function(m, efficiency, charge,
                   satu = "linear",
                   c = 1, e = 1,
                   approxN = F){
  #Function used for 1 cycle of amplification
  #ApproxN = Normal approximation
  if (!approxN){
    m <- floor(m)
  }
  if(satu != "linear"){
    #mechanistic saturation
    gamma <- function(x){
      2/(1+sqrt(1-4*c^2*x*(1-x)))
    }
    lambda <- efficiency*c*gamma(charge)*(1-charge)*(e-charge)
  }
  else{
    lambda <- max(0, efficiency*(1-charge))
  }
  if (approxN){
    nb <- rnorm(1, mean = m*lambda,
                sd = sqrt(m*lambda*(1-lambda))) #nb of new molecules
  }
  else {
    nb <- rbinom(1, m, lambda) #nb of new molecules
  }
  return(nb)
}

simu_pcr <- function(cycles = ncycles,
                       m0=1,
                       lambda=1,
                       K=Inf,
                       satu = "linear",
                       c = 1,
                       e = 1,
                       delta = 1,
                       approxN = F) {
  param <- data.frame(m0 = m0,
                      lambda = lambda)
  
  nspecies <- nrow(param)
  
  #Number of molecules of each species at each cycle
  kinetics <- matrix(0, nrow = cycles+1, ncol = nspecies)
  if (delta <= 1){
    kinetics[1,] <- rpois(length(m0), m0)
  } else {
    kinetics[1,] <- rnbinom(length(m0), m0/delta, 1/delta)
  }
  init <- kinetics[1,]
  
  for (cyc in 2:(1+cycles)) {
    n <- sum(kinetics[cyc-1,])
    for (m in 1:nspecies) {
      mc <- kinetics[cyc-1,m]
      ampli <- amplif(mc, param$lambda[m], 
                      ((n-init[m])/K),
                      satu = satu, c = c, e = e,
                      approxN = approxN)
      kinetics[cyc,m] <- kinetics[cyc-1,m]+ampli
    }
  }
  return(kinetics)
}

#infer best parameters with logistic model
fcrit_logistic <- function(par,
                           data = NULL,
                           K = 1e11,
                           low_cycle = 20, high_cycle = 40){
  m0 <- 10^par[1]
  lam <- par[2]
  set.seed(123456) #fix randomness
  p <- simu_pcr(m0=m0, lambda=lam, 
                  K=K,
                  cycles = ncycles, approxN = T)
  crit <- sum(((p[low_cycle:high_cycle+1]-
                  data$molecules[low_cycle:high_cycle])/
                    data$molecules[low_cycle:high_cycle])^2)
  crit <- crit * (1+2e1*abs(max(p)-K)/K)
  return(crit)
}

#infer best parameters with mechanistic model
fcrit_mechanistic <- function(par,
                             data = NULL, K = 1e11,
                             low_cycle = 20, high_cycle = 40){
  m0 <- 10^par[1]
  lam <- par[2]
  c <- par[3]
  e <- par[4]
  
  set.seed(123456) #Fix randomness
  p <- simu_pcr(m0=m0,lambda=lam,
                  K=K,
                  satu ="",
                  cycles = ncycles, c = c, e = e,
                  approxN = T)
  crit <- sum(((p[low_cycle:high_cycle+1]-data$molecules[low_cycle:high_cycle])/
                 data$molecules[low_cycle:high_cycle])^2)
  crit <- crit * (1+2e1*abs(max(p)-K)/K)
  return(crit)
}

#Best fit exponential model
fcrit_exp <- function(par,
                      data = NULL, K = 1e11,
                      low_cycle = 20, high_cycle = 40){
  m0 <- 10^par[1]
  lam <- par[2]
  set.seed(123456)
  p <- m0*(1+lam)^seq(0:ncycles)
  crit <- sum(((p[low_cycle:high_cycle+1]-
                  data$molecules[low_cycle:high_cycle])/
                    data$molecules[low_cycle:high_cycle])^2)
  crit <- crit
  return(crit)
}
```

***virer comm



```{r qpcr open data}

ampli <- read.csv("data/20210712_101200_CT030043_SPER01_ANALYSE -  Quantification Amplification Results_SYBR.csv")[,-1]

ampli <- ampli %>% pivot_longer(2:ncol(ampli))
colnames(ampli)[2:3]<- c("Well","RFU")

a <- K/(max(ampli$RFU)-min(ampli$RFU))
b <- -a*min(ampli$RFU)

ampli$molecules <- a * ampli$RFU + b

ampli <- ampli[ampli$Well == "B7",] #B7: species Cbp, sample 26

```

***Les paramètres sont ajustés de manière numérique, sans chercher à les accorder avec le sens biologique ici.

***à retrouver :

mct1
high cycle

rendre les nombres de cycles homogène



```{r qpcr fit}

#Determine the part of the kinetics that is significant

KWell <- max(ampli$molecules)

Mct1 <- KWell/10 #***

low_cycle <- high_cycle

while ((ampli %>%
       pull(molecules))[low_cycle] > Mct1){
    low_cycle <- low_cycle -1
  }
low_cycle <- low_cycle +1




#Fit logistic model
opt_log <- optim(c(5, 0.6), fcrit_logistic,
                   data = ampli,
                   K = KWell,
                   low_cycle= low_cycle,
                   high_cycle = high_cycle,
                   lower = c(1, 0.3), upper = c(10, 1),
                   method = "L-BFGS-B")
  
m0log <- opt_log$par[1]
lamlog <- opt_log$par[2]
  
#Fit mechanistic model
#First step

opt_mec <- optim(c(5.75, 0.55,  0.75, 1.15),
                   fcrit_mechanistic,
                   data = ampli,
                   K = KWell,
                   low_cycle= low_cycle, high_cycle = high_cycle,
                   lower = c(1, 0.4, 0.5, 0.8),
                   upper = c(10, 0.7, 1, 1.4),
                   method = "L-BFGS-B")
  
m0mec <- opt_mec$par[1]
lammec <- opt_mec$par[2]
cmec <- opt_mec$par[3]
emec <- opt_mec$par[4]

#Second step, fixed e

opt_mec <- optim(c(5.75, 0.55,  0.75, emec),
                   fcrit_mechanistic,
                   data = ampli,
                   K = KWell,
                   low_cycle= low_cycle, high_cycle = high_cycle,
                   lower = c(1, 0.4, 0.5, emec*0.99),
                   upper = c(10, 1/emec*0.99, 1, emec*1.01),
                   method = "L-BFGS-B")
  
m0mec <- opt_mec$par[1]
lammec <- opt_mec$par[2]
cmec <- opt_mec$par[3]
emec <- opt_mec$par[4]

#Fit exponential model

opt_exp <- optim(c(5.75, 0.55),
                   fcrit_exp,
                   data = ampli,
                   K = KWell,
                   low_cycle= low_cycle,
                 high_cycle = 24,
                   lower = c(1, 0.4),
                   upper = c(10, 0.9),
                   method = "L-BFGS-B")

#Simulate PCR
#Logistic model
plog <- simu_pcr(m0=10^m0log,
                   lambda=lamlog,
                   K=KWell,  
                   cycles = ncycles)

#Mechanistic model
pmec <- simu_pcr(m0=10^m0mec,
                   lambda=lammec,
                   K=KWell,
                   satu ="", cycles = ncycles,
                   e = emec,
                   c = cmec)

#Exponential model
modele_exp <- 10^opt_exp$par[1]*(1+opt_exp$par[2])^seq(0:ncycles)
```

Figure of the paper

```{r saturation models - figure}
#Figure
ggplot()+
        geom_point(data = ampli, aes(Cycle, molecules))+
        geom_line(data = NULL, aes(0:ncycles, plog[,1],
                                   col = "logistic"),
                  linewidth = 0.75)+
        geom_line(aes(0:ncycles, modele_exp,
                      col = "None\n(exponential)"),
                  linewidth = 0.75)+
        # geom_line(aes(0:ncycles, pmec[,1],
        #               col = "mechanistic"), linewidth = 0.75)+
        labs(y = "Estimated number of molecules", 
             col = "Saturation\nmodel")+
        theme(legend.justification = c(1, 0),
              legend.position = c(1, 0),
        legend.box.margin=margin(rep(10, 4)))+
  coord_cartesian(xlim = c(0, 50), ylim = c(0, K))+
        ggtitle(
          paste0("Real qPCR data and saturation models - Species : ",
                       "Capsella bursa-pastoris"))

# ggsave(filename = "saturation_models2.pdf",
#        dpi = 600, units = "mm",
#        width = 180, height = 120, device = "pdf")

```

## Inférence***

flimo, julia

## fig***

```{r}



#Ajout sp -> rev avec summary_dd***
df_Sper01_targetU <- df_Sper01_targetU %>%
  left_join(data_dd_fig %>% select(species_name, sp) %>%
              distinct(sp, .keep_all = T))

df_Sper01_targetT <- df_Sper01_targetT %>%
  left_join(data_dd_fig %>% select(species_name, sp) %>%
              distinct(sp, .keep_all = T))

df_Sper01_targetG <- df_Sper01_targetG %>%
  left_join(data_dd_fig %>% select(species_name, sp) %>%
              distinct(sp, .keep_all = T))

df_inferT <- df_inferT %>% mutate(species_name = as.character(species_name)) %>%
  left_join(data_dd_fig %>% select(species_name, sp) %>%
              distinct(sp, .keep_all = T))

df_inferG <- df_inferG %>% mutate(species_name = as.character(species_name)) %>%
  left_join(data_dd_fig %>% select(species_name, sp) %>%
              distinct(sp, .keep_all = T))


order <- df_Sper01_targetG %>% filter(species_name != "Spike1") %>%
  group_by(species_name) %>%
  summarise(order = rank[1]) %>% pull(species_name) #rev***

colp <- c("Expected" = "gold", "Observed\n(Median)" = "brown3")

gobsU1 <- ggplot(df_Sper01_targetU %>%
                   filter(sum_count_sample > reads_threshold & !NegControl &
                            species_name != "Spike1" & Spike_level == 1))+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop_nospk))+
  theme(axis.text.x=element_blank())+
  ggtitle("Uniform community")+
  theme(plot.title = element_text(hjust = 0.5))+
  labs(y = "", x = "")+
  geom_hline(yintercept = 1/length(unique(recapU1$species_name)),
             color = "gold")

gobsT1 <- ggplot(df_Sper01_targetT %>%
                   filter(sum_count_sample > reads_threshold & !NegControl &
                            species_name != "Spike1" & Spike_level == 1))+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop_nospk))+
  theme(axis.text.x=element_blank())+
  ggtitle("Uniform in Total DNA community")+
  theme(plot.title = element_text(hjust = 0.5))+
  # geom_text(aes(3, 0.25, label = "Raw data"), size = 4)+
  labs(y = "", x = "", fill = "")+
  geom_point(data = commuT1 %>%
               filter(species_name != "Spike1" & Spike_level == 1),
             aes(sp, prop_expected, fill = "Expected"),
             shape = 23,
             size = 3)+
  geom_hline(yintercept = 1/length(unique(recapU1$species_name)),
             color = "gold", linetype = "dashed")+
  scale_fill_manual(values = colp)

highlight = function(x, pat, color="black", family="") {
  ifelse(grepl(pat, x), glue("<b style='font-family:{family}; color:{color}'>{x}</b>"), x)
}

gobsG1 <- ggplot(df_Sper01_targetG %>%
                   filter(sum_count_sample > reads_threshold & !NegControl &
                            species_name != "Spike1" & Spike_level == 1))+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop_nospk))+
  labs(y = "", x = "")+
  ggtitle("Geometric community")+
  theme(plot.title = element_text(hjust = 0.5))+
  geom_point(data = commuG1[commuG1$species_name != "Spike1" &
                              commuG1$Spike_level == 1,],
             aes(sp, prop_expected), shape = 23,
             fill = "gold", size = 3)+
  scale_y_log10()+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
  theme(axis.text.x=element_markdown())

fig <- egg::ggarrange(gobsU1, gobsT1, gobsG1,
                  ncol = 1)
annotate_figure(fig,
                top = text_grob("Final abundances in three mock communities with Sper01"),
                bottom = text_grob("Species"),
                left = text_grob("Observed reads proportions", rot = 90))

# ggsave("metabar_results.pdf", units = "mm",
#        width = 180, height = 200, dpi = 600, device = "pdf")


##Figure avec correction des proportions par commu U

ginferT1 <- ggplot(df_inferT)+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop_infer))+
  geom_point(data = df_inferT %>% group_by(sp) %>%
               summarise(prop = median(prop)),
    aes(sp, prop, fill = "Observed\n(Median)"),
             shape = 21, size = 3)+
  # geom_text(aes(3, 0.2, label = "Corrected data"), size = 4)+
  theme(axis.text.x=element_blank())+
  labs(y = "", x = "",
       fill = "", col = "")+
  geom_point(data = commuT1[commuT1$species_name != "Spike1" &
                              commuT1$Spike_level == 1,],
             aes(sp, prop_expected, fill = "Expected"), shape = 23,
             size = 3)+
  scale_fill_manual(values = colp)+
  ggtitle("Uniform in Total DNA community")+
  theme(plot.title = element_text(hjust = 0.5))


ginferG1 <- ggplot(df_inferG)+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop_infer))+
  geom_point(data = df_inferG %>% group_by(sp) %>%
               summarise(prop = median(prop)),
             aes(sp, prop, fill = "Observed\n(Median)"),
             shape = 21, size = 3)+
  # geom_text(aes(3, 0.2, label = "Corrected data"), size = 4)+
  labs(y = "", x = "",
       fill = "", col = "")+
  geom_point(data = commuG1[commuG1$species_name != "Spike1" &
                              commuG1$Spike_level == 1,],
             aes(sp, prop_expected, fill = "Expected"), shape = 23,
             size = 3)+
  scale_fill_manual(values = colp)+
  ggtitle("Geometric community")+
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "none")+
  scale_y_log10()+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
  theme(axis.text.x=element_markdown())

fig <- egg::ggarrange(ginferT1, ginferG1,
                      ncol = 1)
annotate_figure(fig,
                top = text_grob("Corrected abundances in two mock communities with Sper01"),
                bottom = text_grob("Species"),
                left = text_grob("Inferred reads proportions", rot = 90))

# ggsave("metabar_results_corrected.pdf", units = "mm",
#        width = 180, height = 150, dpi = 600, device = "pdf")


ginferG1_bis <- ggplot(df_inferG)+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop_infer))+
  geom_point(data = df_inferG %>% group_by(sp) %>%
               summarise(prop = median(prop)),
             aes(sp, prop, fill = "Observed\n(Median)"),
             shape = 21, size = 3)+
  # geom_text(aes(3, 0.2, label = "Corrected data"), size = 4)+
  labs(y = "Inferred reads proportions", x = "Species",
       fill = "", col = "")+
  geom_point(data = commuG1[commuG1$species_name != "Spike1" &
                              commuG1$Spike_level == 1,],
             aes(sp, prop_expected, fill = "Expected"), shape = 23,
             size = 3)+
  scale_fill_manual(values = colp)+
  ggtitle("Corrected abundances in the Geometric community")+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_log10()+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
  theme(axis.text.x=element_markdown())

# ggsave("metabar_results_corrected_G.pdf", units = "mm",
#        width = 180, height = 150, dpi = 600, device = "pdf")


```




## ***Simulations pour montrer l'impact des différences de rendement

Simulated amplification to quantify the effect of a efficiency difference

```{r}
nspecies <- 2
ncycles <- 40
M0 = rep(2.5e5/nspecies, nspecies)

lam1 <- 0.9
Lam2 <- seq(0.85, 1, by = 0.001)

res <- NULL

sim <- NULL
for (lam2 in Lam2){
  p <- simu_pcr(m0=M0, lambda=c(lam1, lam2), K=K, cycles = ncycles)
  res <- rbind(res, p[ncycles+1,])
}

ggplot()+
  geom_line(aes(Lam2/lam1-1, res[,2]/(rowSums(res)), col = "2"))+
  geom_line(aes(Lam2/lam1-1, res[,1]/(rowSums(res)), col = "1"))+
  ggtitle("Simulated mock community with two species\nwith equal starting quantities")+
  geom_hline(yintercept = 0.5, linetype = "dashed")+
  theme(plot.title = element_text(hjust = 0.5))+
  labs(x = "Relative variation of PCR efficiency", y = "Final relative abundances", col = "Species")+
  ylim(0, 1)+
  coord_cartesian(xlim = c(0, 0.1))

# ggsave(filename = "simulambda.pdf", units = "mm",
#        height = 120, width = 180, device = "pdf", dpi = 600)

```

