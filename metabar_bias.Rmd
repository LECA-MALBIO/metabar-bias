
---
title: 'How much PCR amplification is biasing DNA metabarcoding results ? - scripts'
author:
  - name: Sylvain Moinard
    institute: leca
    email: sylvain.moinard@univ-grenoble-alpes.fr
    correspondence: true
  - name: Didier Piau
    institute: ijf
  - name: Frédéric Laporte
    institute: leca
  - name: Delphine Rioux
    institute: leca
  - name: Pierre Taberlet
    institute: leca
  - name: Christelle Gonindard-Melodelima
    institute: leca
  - name: Eric Coissac
    institute: leca
    email: eric.coissac@metabarcoding.org 
    correspondence: true
institute:
  - leca: Univ. Grenoble-Alpes, Univ. Savoie Mont Blanc, CNRS, LECA, 38000, Grenoble, France.
  - ijf: Univ. Grenoble-Alpes, CNRS, Institut Joseph Fourier, 38000, Grenoble, France.
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(egg)
library(ggpubr)
library(ggplot2)
theme_set(theme_classic())
library(ggrepel)
library(ggtext)
library(glue)
library(latex2exp)
library(readxl)
library(tidyverse)

options(rgl.useNULL=TRUE)
library(rgl)
library(qpcR)

```

Script for the manuscript ***
Data is processed in the data_processing.Rmd file.

Last edit: 09/07/2023

## ddPCR analysis

digital droplet PCR (ddPCR) data

Cmolecules-ref : Copies of target molecules per ng of total DNA

```{r open ddpcr data}
dataddpcr <- read_csv("data/dataddpcr.csv")

extraction <- read_excel(
  "data/dosage extraction plantes.xlsx")
extraction <- extraction[-nrow(extraction),]
extraction <- extraction[,-(4:9)]

Vmix_dd <- 20 #ul
Vdna_dd <- 5 #ul

CtotDNA_ref <- 2.5e-3 *Vdna_dd/Vmix_dd

summary_dd <- dataddpcr %>% filter(Used & Sample < 100) %>%
  group_by(Sample) %>%
  summarise(sp = sp[1],
            Mean = mean(Concentration/TotalDNA),
            min = min(Concentration/TotalDNA),
            max = max(Concentration/TotalDNA)) %>%
  left_join(extraction %>% dplyr::select(Espece, Sample, `concentration (ng/µl`)) %>%
  rename(CDNA_sample = `concentration (ng/µl`,
         Cmolecules_ref = Mean,
         species_name = Espece) %>%
  dplyr::select(Sample, species_name, sp, Cmolecules_ref, CDNA_sample)
```

## Metabarcoding preparation 

DNA concentration in the different communities

### Uniform community (U)

```{r dna concentration}
CDNA_T <- 0.5 #Total DNA concentration (ng/ul) for all plants in the T community (concentration in sample, not in pcr mix)
C_species_ref <- CDNA_T/13 #concentration of Pt6, ng/ul

summary_dd <- summary_dd %>%
  mutate(Volume_equi = max(Cmolecules_ref)/Cmolecules_ref,
         cDNA_U = C_species_ref*Volume_equi,
         molecules_U = cDNA_U*Cmolecules_ref,
         propU = molecules_U/sum(molecules_U))
#molecules/ul in sample
```

Number of molecules in the U community

```{r commu U}
VDNA_metab <- 2 #ul
VDNA_metab * summary_dd$molecules_U
VDNA_metab * sum(summary_dd$molecules_U)
```

### "Uniform in Total DNA" Communauty (T)

Number of molecules in the T community

```{r commu T}
summary_dd <- summary_dd %>%
  mutate(molecules_T = C_species_ref*Cmolecules_ref,
         propT = molecules_T/sum(molecules_T))

VDNA_metab * summary_dd$molecules_T
VDNA_metab * sum(summary_dd$molecules_T)

```

### Geometric community (G)

2-fold dilution

Number of molecules in the T community

```{r commu G}
summary_dd <- summary_dd %>%
  mutate(RankG = 13 - rank(CDNA_sample/Volume_equi) + 1,
         cDNA_G = CDNA_T/2^RankG*Volume_equi,
         molecules_G = cDNA_G*Cmolecules_ref,
         propG = molecules_G/sum(molecules_G))

summary_dd$molecules_G * VDNA_metab
sum(summary_dd$molecules_G) * VDNA_metab
```

### Figure

Figure 3 of the manuscript

```{r ddpcr analysis}
data_dd_fig <- dataddpcr %>% filter(Used & Sample < 100) %>%
  left_join(summary_dd %>% dplyr::select(sp, species_name, RankG))

order_short <- summary_dd %>% dplyr::select(sp, RankG) %>%
  arrange(-RankG) %>% pull(sp)

highlight <- function(x, pat, color="black", family="") {
  ifelse(grepl(pat, x), glue("<b style='font-family:{family}; color:{color}'>{x}</b>"), x)
}

ggplot(data_dd_fig)+
  geom_point(aes(factor(sp, levels = order_short, ordered = T),
                 Concentration_copies_ng/1000,
                 shape = as.factor(TotalDNA)))+
  geom_point(data = summary_dd,
             aes(as.factor(sp), Cmolecules_ref/1000),
             fill = "red", shape = 23, size = 3)+
  # ggtitle("Target DNA molecules for Total DNA concentration = 6.25e-4 ng/ul")+
  labs(x = "Plant species",
       y = "Thousands of molecules per ng of total DNA\n",
       shape = TeX("Concentration (ng/$\\mu l$)"))+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
  theme(axis.text.x=element_markdown(),
        legend.title.align=0.5)

ggsave(filename = "ddpcr_fig_clean.pdf",
       dpi = 600, units = "mm",
       width = 180, height = 130, device = "pdf")
```

Stats ddpcr

```{r stats ddpcr}

summary_dd$Cmolecules_ref %>% summary

```


## Metabarcoding analysis

Pipeline from raw data: see data_processing file

Open data, filter bad PCR replicates.

```{r open metabarcoding data}

df_Sper01 <- read_csv("data/df_Sper01.csv")
summary_sample <- df_Sper01 %>%
  group_by(Sample) %>%
  summarise(total_count_sample = sum(reads),
            NegControl = NegControl[1],
            Spike_level = Spike_level[1],
            Community = Community[1]) %>%
  arrange(total_count_sample)

summary(summary_sample$total_count_sample)
summary(summary_sample %>%
          filter(!NegControl) %>% pull(total_count_sample))
sd(summary_sample %>%
          filter(!NegControl) %>% pull(total_count_sample))

reads_threshold <- 5000

ggplot(summary_sample %>%
          filter(!NegControl))+
  geom_point(aes(x = 1:nrow(summary_sample %>%
          filter(!NegControl)),
                 y = total_count_sample,
                 shape = Community))+
  labs(col = "Spike_level")+
  scale_y_log10()+
  geom_hline(yintercept = reads_threshold)

```


### Uniform Community (U)

```{r open barcodes}
barcodes1 <- read_excel("data/new_plant_positive_control.xlsx")[,c(2,4:6)]
names(barcodes1) <- c("species_name", "sequence", "length", "gc_content")

barcodes1[barcodes1$species_name ==
            "Salvia_pratensis",]$sequence <- "atcctgttttctcaaaacaaaggttcaaaaaacgaaaaaaaaaaag"
```


```{r analysis U}
df_targetU <- df_Sper01 %>% filter(Community == "U" &
                                   species_name %in% barcodes1$species_name &
                        species_name != "Rumex_acetosa" &
                          total_count_sample > reads_threshold &
                          !NegControl) %>%
  mutate(prop = obiclean_weight/total_count_sample) %>%
  left_join(summary_dd %>% dplyr::select(species_name, sp, propU)) %>%
  rename(prop_expected = propU)
```




### uniform in Total DNA Community (T)

```{r analysis T}
df_targetT <- df_Sper01 %>% filter(Community == "T" &
                                   species_name %in% barcodes1$species_name &
                        species_name != "Rumex_acetosa" &
                          total_count_sample > reads_threshold &
                          !NegControl) %>%
  mutate(prop = obiclean_weight/total_count_sample) %>%
  left_join(summary_dd %>% dplyr::select(species_name, sp, propT)) %>%
  rename(prop_expected = propT)
```

### Geometric Community (G)

```{r analysis G}
df_targetG <- df_Sper01 %>% filter(Community == "G" &
                                   species_name %in% barcodes1$species_name &
                        species_name != "Rumex_acetosa" &
                          total_count_sample > reads_threshold &
                          !NegControl) %>%
  mutate(prop = obiclean_weight/total_count_sample) %>%
  left_join(summary_dd %>% dplyr::select(species_name, sp, propG)) %>%
  rename(prop_expected = propG)
```

Figure 4 of the manuscript

```{r observed proportions}
colp <- c("Expected" = "gold",
          "Expected\nwithout\nPCR bias" = "gold",
          "Expected\nwithout\nPCR and\nconcentration\nbiases" = "gold",
          "Observed\n(Median)" = "red",
          "Inferred\nwith model" = "darkolivegreen2")

gobsU1 <- ggplot(df_targetU)+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop))+
      geom_point(data = summary_dd,
             aes(sp, 1/nrow(summary_dd),
                 fill = "Expected\nwithout\nPCR bias"),
             shape = 23,
             size = 3)+
    geom_hline(aes(yintercept = 1/nrow(summary_dd),
                 col = "Expected\nwithout\nPCR and\nconcentration\nbiases"),
             linetype = "dashed")+
  ggtitle(TeX("Uniform community (${{M}_U}$)"))+
  labs(y = "", x = "", fill = "", col = "")+
  ylim(min(df_targetT$prop), max(df_targetT$prop)) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x=element_markdown(),
        legend.title.align=0.5)+
  scale_color_manual(values = colp)+
  scale_fill_manual(values = colp)+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))
  

gobsT1 <- ggplot(df_targetT)+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop))+
    geom_point(data = summary_dd,
             aes(sp, propT, fill = "Expected\nwithout\nPCR bias"),
             shape = 23,
             size = 3)+
  geom_hline(aes(yintercept = 1/nrow(summary_dd), col = "Expected\nwithout\nPCR and\nconcentration\nbiases"),
             linetype = "dashed")+
  ggtitle(TeX("Uniform in Total DNA community (${{M}_T}$)"))+
  labs(y = "", x = "", fill = "", col = "")+
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x=element_markdown(),
        legend.title.align=0.5)+
  scale_color_manual(values = colp)+
  scale_fill_manual(values = colp)+
    scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))


# gobsG1 <- ggplot(df_targetG)+
#   geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
#                    prop))+
#   labs(y = "", x = "")+
#   ggtitle("Geometric community (G)")+
#   theme(plot.title = element_text(hjust = 0.5))+
#   geom_point(data = summary_dd,
#              aes(sp, propG), shape = 23,
#              fill = "gold", size = 3)+
#   scale_y_log10()

fig <- ggpubr::ggarrange(gobsU1, gobsT1, #gobsG1,
                  ncol = 1,
                  common.legend = T,
                  legend = "right")
annotate_figure(fig,
                # top = text_grob("Final abundances in two mock communities with Sper01"),
                bottom = text_grob("Species"),
                left = text_grob("Observed reads proportions", rot = 90))

# ggsave("metabar_results.pdf", units = "mm",
#        width = 150, height = 200, dpi = 600, device = "pdf")
```

Proportions of Ptr in U

```{r ptr prop}
df_targetU %>% filter(sp == "Ptr") %>% pull(prop) %>% summary
df_targetU %>% filter(sp == "Ptr") %>% pull(prop) %>% sd

df_targetU %>% group_by(sp) %>% summarise(s = sd(prop), m = mean(prop)) %>%arrange(m)

df_targetG %>% group_by(sp) %>% summarise(s = sd(prop), m = mean(prop)) %>%arrange(m)
```


Export to Julia to infer efficiencies

```{r export julia U}
readsU <- df_targetU %>%
  dplyr::select(Sample, obiclean_weight, species_name) %>%
  pivot_wider(names_from = species_name, values_from = obiclean_weight) %>% ungroup %>% dplyr::select(-Sample)

# write_csv(readsU, "data/reads_U.csv")

readsT <- df_targetT %>%
  dplyr::select(Sample, obiclean_weight, species_name) %>%
  pivot_wider(names_from = species_name, values_from = obiclean_weight) %>% ungroup %>% dplyr::select(-Sample)

# write_csv(readsT, "data/reads_T.csv")

readsG <- df_targetG %>%
  dplyr::select(Sample, obiclean_weight, species_name) %>%
  pivot_wider(names_from = species_name,
              values_from = obiclean_weight,
              values_fill = 0) %>% ungroup %>% dplyr::select(-Sample)

# write_csv(readsG, "data/reads_G.csv")
```

### Correction from a mock community (U)

Correction factor is:

a_s = prop_obs(s)/prop_init(s) (* constant value)

then prop_infer(s) = prop_obs(s)/a_s(commuU)


```{r correction mock}
order_sp <- summary_dd %>% dplyr::select(species_name, RankG) %>%
  arrange(-RankG) %>% pull(species_name)

correcU <- df_targetU %>%
  group_by(species_name) %>%
  summarise(correc = median(prop)/prop_expected[1])

#U
df_targetU <- df_targetU %>% left_join(correcU)
df_targetU$prop_infer_mock <- df_targetU$prop/df_targetU$correc
df_targetU <- df_targetU %>%
  group_by(Sample) %>%
  mutate(prop_infer_mock = prop_infer_mock/sum(prop_infer_mock,
                                               na.rm = T))

df_targetU$species_name <- factor(df_targetU$species_name,
                                  levels = order_sp,
                                  ordered = T)

#T
df_targetT <- df_targetT %>% left_join(correcU)
df_targetT$prop_infer_mock <- df_targetT$prop/df_targetT$correc
df_targetT <- df_targetT %>%
  group_by(Sample) %>%
  mutate(prop_infer_mock = prop_infer_mock/sum(prop_infer_mock,
                                               na.rm = T))
df_targetT$species_name <- factor(df_targetT$species_name,
                                  levels = order_sp,
                                  ordered = T)

#G
df_targetG <- df_targetG %>% left_join(correcU)
df_targetG$prop_infer_mock <- df_targetG$prop/df_targetG$correc
df_targetG <- df_targetG %>%
  group_by(Sample) %>%
  mutate(prop_infer_mock = prop_infer_mock/sum(prop_infer_mock,
                                               na.rm = T))

df_targetG$species_name <- factor(df_targetG$species_name,
                                  levels = order_sp,
                                  ordered = T)
```


```{r T adn G corrected by U}

# ginferT1 <- ggplot(df_targetT)+
#   geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
#                    prop_infer_mock))+
#   geom_point(data = df_targetT %>% group_by(sp) %>%
#                summarise(prop = median(prop)),
#     aes(sp, prop, fill = "Observed\n(Median)"),
#              shape = 21, size = 3)+
#   theme(axis.text.x=element_blank())+
#   labs(y = "", x = "",
#        fill = "", col = "")+
#   geom_point(data = summary_dd,
#              aes(sp, propT, fill = "Expected"), shape = 23,
#              size = 3)+
#   scale_fill_manual(values = colp)+
#   ggtitle("Uniform in Total DNA community (T)")+
#   theme(plot.title = element_text(hjust = 0.5))
# 
# ginferG1 <- ggplot(df_targetG)+
#   geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
#                    prop_infer_mock))+
#   geom_point(data = df_targetG %>% group_by(sp) %>%
#                summarise(prop = median(prop)),
#              aes(sp, prop, fill = "Observed\n(Median)"),
#              shape = 21, size = 3)+
#   labs(y = "", x = "",
#        fill = "", col = "")+
#   geom_point(data = summary_dd,
#              aes(sp, propG, fill = "Expected"), shape = 23,
#              size = 3)+
#   scale_fill_manual(values = colp)+
#   ggtitle("Geometric community (G)")+
#   theme(plot.title = element_text(hjust = 0.5),
#         legend.position = "none")+
#   scale_y_log10()+
#   scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
#   theme(axis.text.x=element_markdown())
# 
# fig <- egg::ggarrange(ginferT1, ginferG1,
#                       ncol = 1)
# annotate_figure(fig,
#                 top = text_grob("Corrected abundances in two mock communities with Sper01"),
#                 bottom = text_grob("Species"),
#                 left = text_grob("Inferred reads proportions", rot = 90))

# ggsave("metabar_results_corrected.pdf", units = "mm",
#        width = 180, height = 150, dpi = 600, device = "pdf")

```



RMSE to compare observed/corrected vs expected proportions

```{r rmse}
resU1 <- df_targetU %>% group_by(species_name) %>%
  summarise(prop = median(prop), prop_expected = prop_expected[1],
            prop_infer = median(prop_infer_mock))

resT1 <- df_targetT %>% group_by(species_name) %>%
  summarise(prop = median(prop), prop_expected = prop_expected[1],
            prop_infer = median(prop_infer_mock))

resG1 <- df_targetG %>% group_by(species_name) %>%
  summarise(prop = median(prop), prop_expected = prop_expected[1],
            prop_infer = median(prop_infer_mock))

#U
summary(resU1$prop)

sqrt(sum((resU1$prop-resU1$prop_expected)^2)/nrow(resU1))
sqrt(sum((resU1$prop_infer-resU1$prop_expected)^2)/nrow(resU1))

sqrt(sum(((resU1$prop-resU1$prop_expected)/resU1$prop_expected)^2)/nrow(resU1))
sqrt(sum(((resU1$prop_infer-resU1$prop_expected)/resU1$prop_expected)^2)/nrow(resU1))

#T
summary(resT1$prop)

sqrt(sum((resT1$prop-resT1$prop_expected)^2)/nrow(resT1))
sqrt(sum((resT1$prop_infer-resT1$prop_expected)^2)/nrow(resT1))

sqrt(sum(((resT1$prop-resT1$prop_expected)/resT1$prop_expected)^2)/nrow(resT1))
sqrt(sum(((resT1$prop_infer-resT1$prop_expected)/resT1$prop_expected)^2)/nrow(resT1))

#RMSE of T if it is considered as a uniform community
sqrt(sum((resT1$prop-resU1$prop_expected)^2)/nrow(resT1))
sqrt(sum(((resT1$prop-resU1$prop_expected)/resT1$prop_expected)^2)/nrow(resT1))

#G
summary(resG1$prop)

sqrt(sum((resG1$prop-resG1$prop_expected)^2)/nrow(resG1))
sqrt(sum((resG1$prop_infer-resG1$prop_expected)^2)/nrow(resG1))

sqrt(sum(((resG1$prop-resG1$prop_expected)/resG1$prop_expected)^2)/nrow(resG1))
sqrt(sum(((resG1$prop_infer-resG1$prop_expected)/resG1$prop_expected)^2)/nrow(resG1))
```
Proportions inferred in julia :

```{r export julia G}
inferG <- read.csv("data/prop_inferG.csv")
colnames(inferG) <- colnames(readsG)
inferG <- inferG %>% pivot_longer(everything(), names_to = "species_name", values_to = "infer_propG") %>%
  left_join(resG1 %>% dplyr::select(species_name, prop_expected)) %>%
  left_join(summary_dd %>% dplyr::select(species_name, sp))


#RMSE 

inferG %>% mutate(abserr = (infer_propG - prop_expected)^2) %>%
  pull(abserr) %>% mean %>% sqrt

inferG %>% mutate(relerr = ((infer_propG - prop_expected)/prop_expected)^2) %>%
  pull(relerr) %>% mean %>% sqrt

```



```{r G corrected by U}
# 
# ginferG1 <- ggplot(df_targetG)+
#   geom_boxplot(aes(factor(sp, levels = order_short,
#                           ordered = T),
#                    prop_infer_mock))+
#   geom_point(data = df_targetG %>% group_by(sp) %>%
#                summarise(prop = median(prop)),
#              aes(sp, prop, fill = "Observed\n(Median)"),
#              shape = 23, size = 2)+
#     geom_point(data = inferG,
#              aes(sp, infer_propG, fill = "Inferred\nwith model"),
#              shape = 23, size = 2)+
#   labs(y = "Initial proportions\ninferred from U", x = "Species",
#        fill = "", col = "")+
#   geom_point(data = summary_dd,
#              aes(sp, propG, fill = "Expected"), shape = 23,
#              size = 2)+
#   scale_fill_manual(values = colp)+
#   ggtitle("Corrected abundances in the Geometric community (G)")+
#   theme(plot.title = element_text(hjust = 0.5))+
#   scale_y_log10()+
#   scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
#   theme(axis.text.x=element_markdown())
# 
# ginferG1

# ggsave("metabar_results_corrected_G.pdf", units = "mm",
#        width = 150, height = 150, dpi = 600, device = "pdf")

```

## Taqman

```{r open taqman}
endpoint <- read.csv2("data/SPER01_End_Point_res.csv")
endpoint <- endpoint[,c("Well", "End.RFU")]

ampli <- read.csv2("data/SPER01_ampli_res.csv")[,-1]

cq <- read.csv2("data/SPER01_Cq_res.csv")
cq <- cq[cq$Fluor == "FAM",c("Well", "Fluor", "Cq")]

taqman <- read_csv("data/taqman.csv")
taqman[taqman$sp == "Fe","sp"] <- "Fex"

cinetique <- ampli %>%
  pivot_longer(!Cycle, names_to = "Well",
               values_to = "RFU")

cinetique$Dilu <- match(substr(cinetique$Well, 1, 1), LETTERS)
cinetique$Repli <- as.integer(substr(cinetique$Well, 2, nchar(cinetique$Well)))

cinetique$probe <- "Fex"
cinetique[cinetique$Repli <= 9, "probe"] <- "Cbp" 
cinetique[cinetique$Repli <= 6, "probe"] <- "CbeB"
cinetique[cinetique$Repli <= 3, "probe"] <- "CbeA"

cinetique$sp <- "Fex"
cinetique[cinetique$Repli <= 9, "sp"] <- "Cbp" 
cinetique[cinetique$Repli <= 6, "sp"] <- "Cbe"
cinetique[cinetique$Repli <= 3, "sp"] <- "Cbe"

cinetique <- cinetique %>% filter(Dilu <= 6) %>%
  mutate(Neg = (Dilu == 6))

res_taqman <- cq %>% left_join(endpoint)

res_taqman$Dilu <- match(substr(res_taqman$Well, 1, 1), LETTERS)
res_taqman$Repli <- as.integer(substr(res_taqman$Well, 2, nchar(res_taqman$Well)))

res_taqman$probe <- "Fex"
res_taqman[res_taqman$Repli <= 9, "probe"] <- "Cbp" 
res_taqman[res_taqman$Repli <= 6, "probe"] <- "CbeB"
res_taqman[res_taqman$Repli <= 3, "probe"] <- "CbeA"

res_taqman$sp <- "Fex"
res_taqman[res_taqman$Repli <= 9, "sp"] <- "Cbp" 
res_taqman[res_taqman$Repli <= 6, "sp"] <- "Cbe"
res_taqman[res_taqman$Repli <= 3, "sp"] <- "Cbe"

res_taqman <- res_taqman %>%
  filter(Dilu <= 6) %>% mutate(Neg = (Dilu == 6))

res_taqman <- res_taqman %>%
  left_join(taqman,
            by = c("sp" = "sp", "Dilu" = "mix"))
```


```{r show taqman results}
ggplot(cinetique %>% filter(!Neg))+
  geom_line(aes(Cycle, RFU, group = Well, col = probe))

ggplot(res_taqman %>% filter(!Neg))+
  geom_point(aes(copies_ul, Cq, group = Well, col = probe))+
  scale_x_log10()+
  labs(y="Ct")+
  ggtitle("Ct = f(log(Concentration))")
```

Linear regression

```{r linear regression taqman}
Vmix_taq <- 25 #ul

res_taqman$slope <- NA
res_taqman$intercept <- NA

for (s in unique(res_taqman$probe)){
  reg <- lm(Cq ~ log10(copies),
            res_taqman %>%
              filter(probe == s & !Neg) %>%
              group_by(Dilu) %>%
              summarise(Cq = mean(Cq),
                        copies = Vmix_taq*copies_ul[1]))
  res_taqman[res_taqman$probe == s, "slope"] <- reg$coefficients[2]
  res_taqman[
    res_taqman$probe == s, "intercept"] <- reg$coefficients[1]
}

res_taqman$rate <- 10^(-1/res_taqman$slope)-1

res_taqman$Mct <- 10^(log10(1+res_taqman$rate)*
                         res_taqman$intercept)

res_taqman %>% group_by(probe) %>%
  summarise(rate = rate[1],
            Mct = Mct[1]/1e10)

```


```{r 2 replicates}
flam <- function(p){
  10^(-1/p)-1
}

res_lm_test <- NULL

for (s in unique(res_taqman$probe)){
  for (try in 1:100){
    reg <- lm(Cq ~ log10(copies),
              res_taqman %>%
                filter(probe == s & !Neg) %>%
                group_by(Dilu) %>%
                summarise(Cq = mean(Cq[sample(1:n(), 2)]),
                          copies = Vmix_taq*copies_ul[1]))
    res_lm_test <- rbind(res_lm_test,
                         data.frame(probe = s,
                                    slope = reg$coefficients[2]))
  }
}

res_lm_test %>% group_by(probe) %>% summarise(min = min(slope),
                                              max = max(slope)) %>%
  mutate(lmin = flam(min), lmax = flam(max), gap = lmax - lmin)

```

###RFU Threshold for each well

```{r rfu}
res_taqman$RFU_Cq <- NA

for (i in 1:nrow(res_taqman)){
  aux <- cinetique %>% filter(Dilu == res_taqman[i,]$Dilu &
                      Repli == res_taqman[i,]$Repli &
                      probe == res_taqman[i,]$probe &
                      abs(Cycle - res_taqman[i,]$Cq)<1)

res_taqman[i,"RFU_Cq"] <- (aux[2,]$RFU - aux[1,]$RFU)*
  (res_taqman[i,]$Cq-aux[1,]$Cycle)+aux[1,]$RFU
}

res_taqman <- res_taqman %>%
  mutate(K = Mct/(RFU_Cq/End.RFU))

Mct_glob <- res_taqman %>% filter(!Neg) %>%
  group_by(sp) %>%
  summarise(Mct = mean(Mct)) %>% pull(Mct) %>% mean

K <- res_taqman %>% filter(!Neg) %>%
  group_by(sp) %>%
  summarise(K = mean(K)) %>% pull(K) %>% sum

```


### Computing PCR efficiencies


```{r pcr efficiencies}
aux <- res_taqman %>% filter(!Neg) %>%
  mutate(Lambda = (Mct_glob/(Vmix_taq*copies_ul))^(1/Cq)-1)

ggplot(aux)+
  geom_point(aes(probe, Lambda, col = factor(Dilu)))

aux %>% group_by(probe) %>% summarise(Lambda = mean(Lambda))
aux %>% group_by(sp) %>% summarise(Lambda = mean(Lambda))

lam <- aux %>% group_by(sp) %>%
  summarise(efficiency = mean(Lambda))

res_taqman <- res_taqman %>% left_join(lam)
```


### Normalise End.RFU for Cbe

```{r normalise rfu cbe}
x <- res_taqman %>% filter(sp == "Cbe" & Dilu < 6) %>%
  group_by(probe, Dilu) %>%
  summarise(end.rfu = mean(End.RFU), Cq = mean(Cq))

correcCbe <- x %>% group_by(Dilu, probe) %>%
  summarise(end.rfu = mean(end.rfu)) %>%
  pivot_wider(names_from = probe, values_from = end.rfu) %>%
  mutate(correc = CbeA/CbeB)


y <- cinetique %>% filter(sp == "Cbe" & !Neg) %>% left_join(correcCbe) %>%
  mutate(RFUbis = ifelse(probe == "CbeB", RFU*correc, RFU))

ggplot(y)+
  geom_line(aes(Cycle, RFU, col = probe, group = Well,
                linetype = factor(Dilu)))

ggplot(y)+
  geom_line(aes(Cycle, RFUbis, col = probe, group = Well,
                linetype = factor(Dilu)))

z <- res_taqman %>% filter(sp == "Cbe" & !Neg)

z$RFU_Cq <- NA
for (i in 1:nrow(z)){
  a <- cinetique %>% filter(Dilu == z[i,]$Dilu &
                      Repli == z[i,]$Repli &
                      probe == z[i,]$probe &
                      abs(Cycle - z[i,]$Cq)<1)

z[i,"RFU_Cq"] <- (a[2,]$RFU - a[1,]$RFU)*
  (z[i,]$Cq-a[1,]$Cycle)+a[1,]$RFU
}

seuil_Cq <- mean(z$RFU_Cq)

fCq <- function(ampli){
  c2 <- which(ampli >= seuil_Cq)[1]
  c1 <- c2-1
  Cq <- (seuil_Cq - ampli[c1]+(ampli[c2] - ampli[c1])*c1)/
    (ampli[c2] - ampli[c1])
  Cq
}

res <- NULL
for (p in unique(y$Well)){
  res <- rbind(res,
               data.frame(Well = p,
                          probe = y[y$Well == p,]$probe[1],
                          Cq = fCq(y[y$Well == p,]$RFU),
                          Cqbis = fCq(y[y$Well == p,]$RFUbis)))
}

ggplot(res_taqman %>% filter(!Neg & sp == "Cbe"))+
  geom_point(aes(Dilu, Cq, col = probe))
```


### Amplification bias

```{r prop commu 3 species}
qmet <- df_targetU %>%
  filter(species_name %in% c("Capsella_bursa-pastoris",
                             "Carpinus_betulus",
                             "Fraxinus_excelsior"))

ggplot(qmet)+
  geom_boxplot(aes(species_name,
                   prop))+
  theme(axis.text.x = element_text(angle = 90))
                   
qmet %>% group_by(species_name) %>%
  summarise(prop = mean(prop)) %>% mutate(prop = prop/sum(prop))

```

## PCR Simulator

Fitting PCR models to qPCR data (SybrGreen) of Capsella bursa-pastoris.


```{r pcr models}

ncycles <- 60
low_cycle <- 20
high_cycle <- 50

amplif <- function(m, efficiency, charge,
                   satu = "linear",
                   c = 1, e = 1,
                   approxN = F){
  #Function used for 1 cycle of amplification
  #ApproxN = Normal approximation
  if (!approxN){
    m <- floor(m)
  }
  if(satu != "linear"){
    #mechanistic saturation
    gamma <- function(x){
      2/(1+sqrt(1-4*c^2*x*(1-x)))
    }
    lambda <- efficiency*c*gamma(charge)*(1-charge)*(e-charge)
  }
  else{
    lambda <- max(0, efficiency*(1-charge))
  }
  if (approxN){
    nb <- rnorm(1, mean = m*lambda,
                sd = sqrt(m*lambda*(1-lambda))) #nb of new molecules
  }
  else {
    nb <- rbinom(1, m, lambda) #nb of new molecules
  }
  return(nb)
}

simu_pcr <- function(cycles = ncycles,
                       m0=1,
                       lambda=1,
                       K=Inf,
                       satu = "linear",
                       c = 1,
                       e = 1,
                       delta = 1,
                       approxN = F) {
  param <- data.frame(m0 = m0,
                      lambda = lambda)
  
  nspecies <- nrow(param)
  
  #Number of molecules of each species at each cycle
  kinetics <- matrix(0, nrow = cycles+1, ncol = nspecies)
  if (delta <= 1){
    kinetics[1,] <- rpois(length(m0), m0)
  } else {
    kinetics[1,] <- rnbinom(length(m0), m0/delta, 1/delta)
  }
  init <- kinetics[1,]
  
  for (cyc in 2:(1+cycles)) {
    n <- sum(kinetics[cyc-1,])
    for (m in 1:nspecies) {
      mc <- kinetics[cyc-1,m]
      ampli <- amplif(mc, param$lambda[m], 
                      ((n-init[m])/K),
                      satu = satu, c = c, e = e,
                      approxN = approxN)
      kinetics[cyc,m] <- kinetics[cyc-1,m]+ampli
    }
  }
  return(kinetics)
}

simu_metabar <- function(cycles = ncycles,
                       m0=1,
                       lambda=1,
                       K=Inf,
                       satu = "linear",
                       c = 1,
                       e = 1,
                       delta = 1,
                       approxN = F,
                       d = 5e-9){
  kinetics_pcr <- simu_pcr(cycles = cycles,
                       m0=m0,
                       lambda=lambda,
                       K=K,
                       satu = satu,
                       c = c,
                       e = e,
                       delta = delta,
                       approxN = approxN)
  amplicons <- kinetics_pcr[nrow(kinetics_pcr),]
  #Sequencing
  if (approxN){
    reads <- rnorm(length(amplicons), mean = amplicons*d,
                   sd = sqrt(d*amplicons*(1-amplicons/K)))
  } else {
    reads <- rbinom(length(amplicons), floor(K*d), amplicons/K)
  }
  reads
}

#Best fit exponential model
fcrit_exp <- function(par,
                      data = NULL, K = 1e11,
                      low_cycle = 20, high_cycle = 40){
  m0 <- 10^par[1]
  lam <- par[2]
  set.seed(123456)
  p <- m0*(1+lam)^seq(0:ncycles)
  crit <- sum(((p[low_cycle:high_cycle+1]-
                  data$molecules[low_cycle:high_cycle])/
                    data$molecules[low_cycle:high_cycle])^2)
  crit <- crit
  return(crit)
}
```


```{r qpcr open data}

ampli <- read.csv("data/20210712_101200_CT030043_SPER01_ANALYSE -  Quantification Amplification Results_SYBR.csv")[,-1]

ampli <- ampli %>% pivot_longer(2:ncol(ampli))
colnames(ampli)[2:3]<- c("Well","RFU")

a <- K/(max(ampli$RFU)-min(ampli$RFU))
b <- -a*min(ampli$RFU)

ampli$molecules <- a * ampli$RFU + b

ampli <- ampli[ampli$Well == "B7",] #B7: species Cbp, sample 26

```

Parameters are fitted numerically. No biological consideration.

Figure 1 of the manuscript

```{r saturation models}
KWell <- max(ampli$molecules)

opt_exp <- optim(c(5.75, 0.55),
                   fcrit_exp,
                   data = ampli,
                   K = KWell,
                   low_cycle= low_cycle,
                 high_cycle = 24,
                   lower = c(1, 0.4),
                   upper = c(10, 0.9),
                   method = "L-BFGS-B")

#Exponential model
modele_exp <- 10^opt_exp$par[1]*(1+opt_exp$par[2])^seq(0:ncycles)
#Figure

# mmec <- cm3
# mmec$expr <- "Fluo ~ mmec$fct(Cycles, c(M0, Lam, K, c, e))"
# mmec$fct <- function(x, parm) {
#   M0 <- parm[1]
#   Lam <- parm[2]
#   if (Lam < 0) return(NA)
#   K <- parm[3]
#   c <- parm[4]
#   e <- parm[5]
#   Fn <- vector(mode = "numeric", length = length(x))
# 
#   gamma <- function(x){
#     2/(1+sqrt(1-4*c^2*x*(1-x)))
#   }
#   for (i in 1:length(x)) {
#     if (i == 1) Fn[i] <- M0
#     else {
#       lam <- Lam*c*gamma(Fn[i - 1]/K)*(1-Fn[i - 1]/K)*(e-Fn[i - 1]/K)
#       if (lam > 1) return(NA)
#       if (Fn[i - 1] < K){Fn[i] <- Fn[i - 1] * (1 + lam) }
#       else {Fn[i] <- Fn[i - 1]}
#     }
#   }
#   return(Fn)
# }
# mmec$ssFct <- function(x, y) {
#   ## start estimates
#   M0 <- 1
#   Lam <- 1
#   K <- max(y)
#   c <- 1
#   e <- 1
#   ssVal <- c(M0, Lam, K, c, e)
#   names(ssVal) <- mlog$parnames
#   return(ssVal)
# }
# mmec$inv <- function(y, parm) {
#   x <- 1:100
#   fn <- function(x, parm) mlog$fct(x, parm) - y
#   uniroot(fn, interval = c(1, 100), parm)$root
# }
# mmec$expr.grad <- expression(mlog$fct(Cycles, c(M0, Lam, K, c, e)))
# mmec$parnames <- c("M0", "Lam", "K", "c", "e")
# mmec$name <- "mmec"
# mmec$type <- "my mec"

mlog <- cm3
mlog$expr <- "Fluo ~ mlog$fct(Cycles, c(M0, Lam, K))"
mlog$fct <- function(x, parm) {
  M0 <- parm[1]
  Lam <- parm[2]
  K <- parm[3]
  Fn <- vector(mode = "numeric", length = length(x))
  for (i in 1:length(x)) {
    if (i == 1) Fn[i] <- M0
    else {
      if (Fn[i - 1] < K){Fn[i] <- Fn[i - 1] * (1 + Lam*(1-Fn[i - 1]/K)) }
      else {Fn[i] <- Fn[i - 1]}
    }
  }
  return(Fn)
}
mlog$ssFct <- function(x, y) {
  ## start estimates
  M0 <- 1
  Lam <- 1
  K <- max(y)
  ssVal <- c(M0, Lam, K)
  names(ssVal) <- mlog$parnames
  return(ssVal)
}
mlog$inv <- function(y, parm) {
  x <- 1:100
  fn <- function(x, parm) mlog$fct(x, parm) - y
  uniroot(fn, interval = c(1, 100), parm)$root
}
mlog$expr.grad <- expression(mlog$fct(Cycles, c(M0, Lam, K)))
mlog$parnames <- c("M0", "Lam", "K")
mlog$name <- "mlog"
mlog$type <- "my log"

weights_log <- c(rep(1, 12), rep(100, 4), 1000, rep(200, 3),
                 rep(50, 5),
                 rep(1, 25), rep(500, 1), rep(0, 10))
# weights <- c(rep(1, 14), rep(10, 11), rep(1, 26), rep(0, 10))

data_ampli <- as.matrix(ampli[,c("Cycle", "RFU")])
data_ampli[,1] <- data_ampli[,1] - 1

fitlog <- pcrfit(data_ampli, 1, 2, mlog,
                 weights = weights_log)
# fitmec <- pcrfit(ampli, 1, 3, mmec, weights = weights)

res_log <- a*fitlog$m$predict(newdata = fitlog$DATA)+b
# res_mec <- a*fitmec$m$predict(newdata = fitmec$DATA)+b
```


```{r saturation models - figure}

ggplot()+
        geom_point(data = ampli, aes(Cycle-1, molecules))+
        geom_line(data = NULL, aes((0:60), res_log,
                                   col = "Logistic"),
                  linewidth = 0.75)+
        geom_line(aes(0:(60-1), modele_exp[-1],
                      col = "Exponential"),
                  linewidth = 0.75)+
        # geom_line(aes(0:(60-1), pmec[-1,1],
        #               col = "mechanistic\n(data not shown)"), linewidth = 0.75)+
        labs(x = "Cycle",
             y = "Estimated number of molecules", 
             col = "Amplification model")+
        theme(legend.justification = c(1, 0),
              legend.position = c(1, 0),
        legend.box.margin=margin(rep(10, 4)))+
  coord_cartesian(xlim = c(0, 50), ylim = c(0, KWell))+
  scale_colour_brewer(palette = "Set1")
        # ggtitle(
        #   paste0("Real qPCR data and saturation models - Species : ",
        #                "Capsella bursa-pastoris"))

# ggsave(filename = "saturation_models2.pdf",
#        dpi = 600, units = "mm",
#        width = 180, height = 120, device = "pdf")

```

## Inference

Julia file inference_metabarcoding.jl

## Simulations showing the impact of small efficiency variations

Simulated amplification to quantify the effect of a efficiency difference

Figure 5 of the manuscript.

```{r simu pcr 2 species}
nspecies <- 2
ncycles <- 40
M0 = rep(2.5e5/nspecies, nspecies)

lam1 <- 1
Lam2 <- seq(0.85, 1, by = 0.001)

res <- NULL

sim <- NULL
for (lam2 in Lam2){
  p <- simu_pcr(m0=M0, lambda=c(lam1, lam2), K=K,
                cycles = ncycles)
  res <- rbind(res, p[ncycles+1,])
}

efficiencies <- t(read_csv("data/efficiencies_U.csv"))
colnames(efficiencies) <- colnames(readsU)
summary_dd <- summary_dd %>% left_join(efficiencies %>% as_tibble() %>% pivot_longer(1:13, names_to = "species_name", values_to = "efficiencies"))

prop2 <- df_targetU %>% group_by(sp) %>%
  summarise(propU = median(prop)) %>% ungroup() %>%
  mutate(propU = propU/(propU+propU[11])) %>% #11 = Rc...
  left_join(summary_dd %>% dplyr::select(sp, efficiencies)) %>%
  mutate(deff = 1-efficiencies) %>% filter(sp != "Rc")
```
figure 5 of the manuscript

```{r simu pcr 2 species : fig}

prop2$labelx <- prop2$deff - 0.0021
prop2[prop2$sp == "Rfe","labelx"] <- prop2[prop2$sp == "Rfe","labelx"]+0.0042
prop2[prop2$sp == "Lco","labelx"] <- prop2[prop2$sp == "Lco","labelx"]+0.0042
prop2[prop2$sp == "Lxy","labelx"] <- prop2[prop2$sp == "Lxy","labelx"]+0.0042
prop2[prop2$sp == "Aal","labelx"] <- prop2[prop2$sp == "Aal","labelx"]+0.0038
prop2[prop2$sp == "Bme","labelx"] <- prop2[prop2$sp == "Bme","labelx"]+0.0037
prop2[prop2$sp == "Cbe","labelx"] <- prop2[prop2$sp == "Cbe","labelx"]+0.0021


ggplot()+
    geom_vline(data = prop2 %>% filter(sp != "Rca"), aes(xintercept = deff),
             col = "grey80")+
    geom_line(aes(1-Lam2/lam1, res[,1]/(rowSums(res)), col = "Rosa canina"))+
  geom_line(aes(1-Lam2/lam1, res[,2]/(rowSums(res)), col = "other"))+
  geom_hline(yintercept = 0.5, linetype = "dashed")+
  # ggtitle("Simulated mock communities of two species with equal starting quantities")+
  # theme(plot.title = element_text(hjust = 0.5))+
  geom_point(data = prop2 %>% filter(sp != "Rca"),
             aes(deff, propU, col = "other"))+
  geom_point(data = prop2 %>% filter(sp != "Rca"),
             aes(deff, 1-propU, col = "Rosa canina"))+
  geom_text(aes(0.115, 0.73, label = "Rosa canina", col = "Rosa canina"),
            size = 4)+
  geom_text(aes(0.115, 0.27, label = "Second species", col = "other"),
            size = 4)+
  geom_text(data = prop2 %>% filter(sp != "Rca") %>% arrange(efficiencies),
              aes(labelx, 1, label = sp),
            col = "grey50",
            size = 3, angle = 90)+
    geom_text(data = prop2 %>% filter(sp %in% c("Cbe", "Cbp", "Fex")) %>%
                arrange(efficiencies),
              aes(labelx, 1, label = sp),
            col = "grey25",
            size = 3, angle = 90)+
  labs(x = "Relative decrease of PCR efficiency compared to Rosa canina",
       y = "Final relative abundances", col = "Species")+
  coord_cartesian(xlim = c(0.006, 0.15), ylim = c(0,1))+
  theme(legend.position = "none")+
  scale_colour_brewer(palette = "Set1")
  #   geom_text_repel(
  #   data = prop2 %>% filter(sp != "Rca"),
  #   aes(deff, propU, label = sp),
  #   size = 4,
  #   min.segment.length = unit(0, 'lines'))

# rep(c(1,0.95), 6)

# ggsave(filename = "simulambda.pdf", units = "mm",
#        height = 120, width = 180, device = "pdf", dpi = 600)

```

