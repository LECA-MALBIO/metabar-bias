
---
title: 'Towards quantitative DNA Metabarcoding: A method to overcome PCR amplification bias - data processing'
author:
  - name: Sylvain Moinard
    institute: leca
    email: sylvain.moinard@univ-grenoble-alpes.fr
    correspondence: true
  - name: Didier Piau
    institute: ijf
  - name: Frédéric Laporte
    institute: leca
  - name: Delphine Rioux
    institute: leca
  - name: Pierre Taberlet
    institute: leca
  - name: Christelle Gonindard-Melodelima
    institute: leca
  - name: Eric Coissac
    institute: leca
    email: eric.coissac@metabarcoding.org 
    correspondence: true
institute:
  - leca: Univ. Grenoble-Alpes, Univ. Savoie Mont Blanc, CNRS, LECA, 38000, Grenoble, France.
  - ijf: Univ. Grenoble-Alpes, CNRS, Institut Joseph Fourier, 38000, Grenoble, France.
output:
  html_document:
    toc: true
    theme: united
---

This script is used to produce the analyses of the paper.
Our data is preprocessed in the data_processing.Rmd file.

Last edit: 10/06/2024


## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(egg)
library(ggpubr)
library(ggplot2)
theme_set(theme_classic())
library(ggrepel)
library(ggtext)
library(glue)
library(latex2exp)
library(readxl)
library(scales)
library(tidyverse)

options(rgl.useNULL=TRUE)
library(rgl)
library(qpcR)

```

## Table 1 and Supplementary Table 1: barcodes

Information about the barcodes used with Sper01 marker.

```{r open barcodes, message = FALSE}
#Extraction data
extraction <- read.csv("data/processed_data/extraction.csv")

#Barcodes information
barcodes <- read_excel("data/plants_info/new_plant_positive_control.xlsx")[,c(2,4:6)]
names(barcodes) <- c("species_name", "sequence", "length", "gc_content")

#Polymorphism for species Salvia pratensis
barcodes[barcodes$species_name ==
            "Salvia_pratensis",]$sequence <-
  "atcctgttttctcaaaacaaaggttcaaaaaacgaaaaaaaaaaag"

barcodes <- barcodes %>% filter(species_name != "Rumex_acetosa")
#This species is not used in this experiment
```

```{r table1, message = FALSE}
#Information about barcodes and extracted concentrations
barcodes %>% left_join(extraction[,-2])
```

## Estimation of carrying capacity K from PCR composition

Molar concentration of the 4 dNTP in well: $c_n=0.8 mM = 0.8.10^{-3}mol/l$
https://assets.fishersci.com/TFS-Assets/LSG/brochures/AmpliTaq-Gold-360-DNA-Polymerase-QRC-061444.pdf

Quantity of primers in well: $n_p= 20 pmol$/PCR
https://www.thermofisher.com/fr/fr/home/life-science/cloning/cloning-learning-center/invitrogen-school-of-molecular-biology/pcr-education/pcr-reagents-enzymes/pcr-component-considerations.html

Volume of well: $V = 20 \mu l$

Avogadro Constant $N_A = 6.02214076\times 10^{23} \: mol^{-1}$

Average length of a sequence: $L=51$ dNTP

Thus, $K=min(\frac{c_n\times V}{L}, \: n_p) \times N_A$

This is the maximum number of molecules that can be created in a well. Around 1e13.

```{r estimation of K}

c_n <- 4*0.2e-3 #concentration of dNTP, mol/l (4*0.2mM)
Vwell <- 20e-6 #volume of a well, l
N_A <- 6.02214076e23 #Avogadro
L <- barcodes$sequence %>% nchar %>% mean
#mean length of a sequence, number of nucleotides

n_p <- 2*5e-6*2e-6 #quantity of primers, mol : 2 (F+R) * 5uM * 2ul 

#Maximum theoretical value of K is Ksup
Ksup <- min(c_n*Vwell/L, n_p)*N_A
Ksup <- n_p*N_A #Primers are limiting

K <- Ksup #K = Ksup assuming PCR reaction is total 
```

## Figure 1: PCR models

Fitting exponential and logistic PCR models to qPCR data (SybrGreen) of Capsella bursa-pastoris. Data and script are described in Supplementary File 1.

### qPCR data

Converting RFU to number of molecules for illustrative purpose (scaling).

```{r qpcr open data}
#Open file containing qPCR data
ampli <- read.csv("data/qpcr_sybr/qpcr_Quantification_Amplification_Results_SYBR.csv")[,-1]

#Ampli : data ready for the plot
ampli <- ampli %>% pivot_longer(2:ncol(ampli))
colnames(ampli)[2:3]<- c("Well","RFU")
ampli <- ampli[ampli$Well == "B7",] #B7: species Cbp, sample 26

#Convert RFU to molecules
slope <- K/(max(ampli$RFU)-min(ampli$RFU))
intercept <- -slope*min(ampli$RFU)
ampli$molecules <- slope * ampli$RFU + intercept

data_ampli <- as.matrix(ampli[,c("Cycle", "RFU")])
data_ampli[,1] <- data_ampli[,1] - 1

ncycles <- nrow(ampli)

```

### Fitting PCR models

Parameters are fitted numerically. No biological consideration here.
The function (pcrfit) and the data structure used come from R package qpcR.

Non-zero low weights are given for numerical reasons.

```{r exponential model}

mexp <- cm3 #Reuse model object from package qPCR

#Define model

mexp$expr <- "Fluo ~ mexp$fct(Cycles, c(M0, Lam))"
mexp$fct <- function(x, parm) {
  #Simulate amplification with the exponential model
  M0 <- parm[1]
  Lam <- parm[2]
  Fn <- vector(mode = "numeric", length = length(x))
  for (i in 1:length(x)) { #for each cycle
    if (i == 1) Fn[i] <- M0
    else {
      Fn[i] <- Fn[i - 1] * (1 + Lam)
    }
  }
  return(Fn)
}
mexp$ssFct <- function(x, y) {
  ## start estimates
  ssVal <- c(1, 1)
  names(ssVal) <- mexp$parnames
  return(ssVal)
}
mexp$inv <- function(y, parm) {
  #Inverse of the amplification function
  x <- 1:100
  fn <- function(x, parm) mexp$fct(x, parm) - y
  uniroot(fn, interval = c(1, 100), parm)$root
}
mexp$expr.grad <- expression(mexp$fct(Cycles, c(M0, Lam)))
mexp$parnames <- c("M0", "Lam")
mexp$name <- "mexp"
mexp$type <- "my exponential model"


#Weight cycles

weights_exp <- c(rep(0, 5), rep(1, 9), rep(1000, 6), rep(0, 41))

#Infer best parameters (GLM)
fitexp <- pcrfit(data_ampli, 1, 2, mexp,
                 weights = weights_exp)

#Convert RFU to number of molecules
res_exp <- slope*fitexp$m$predict(newdata = fitexp$DATA) + intercept

```

```{r logistic model}

mlog <- cm3 #Reuse model object from package qPCR

#Define model

mlog$expr <- "Fluo ~ mlog$fct(Cycles, c(M0, Lam))"
mlog$fct <- function(x, parm) {
    #Simulate amplification with the logistic model
  M0 <- parm[1]
  Lam <- parm[2]
  K <- max(ampli$RFU) #specific to this amplification
  Fn <- vector(mode = "numeric", length = length(x))
  for (i in 1:length(x)) {
    if (i == 1) Fn[i] <- M0
    else {
      if (Fn[i - 1] < K){Fn[i] <- Fn[i - 1] * (1 + Lam*(1-Fn[i - 1]/K)) }
      else {Fn[i] <- Fn[i - 1]}
    }
  }
  return(Fn)
}
mlog$ssFct <- function(x, y) {
  ## start estimates
  K <- max(ampli$RFU)
  ssVal <- c(1, 1)
  names(ssVal) <- mlog$parnames
  return(ssVal)
}
mlog$inv <- function(y, parm) {
  #Inverse of the amplification function
  x <- 1:100
  fn <- function(x, parm) mlog$fct(x, parm) - y
  uniroot(fn, interval = c(1, 100), parm)$root
}
mlog$expr.grad <- expression(mlog$fct(Cycles, c(M0, Lam)))
mlog$parnames <- c("M0", "Lam")
mlog$name <- "mlog"
mlog$type <- "my logistic model"


#Weight cycles

weights_log <- c(rep(0, 5), rep(1, 9), rep(1000, 10), rep(1, 15), rep(0, 22))

#Infer best parameters (GLM)
fitlog <- pcrfit(data_ampli, 1, 2, mlog,
                 weights = weights_log)

#Convert RFU to number of molecules
res_log <- slope*fitlog$m$predict(newdata = fitlog$DATA) + intercept

```

### Figure 1: Fitted PCR models

```{r saturation models - figure 1}

ggplot()+
        #Data:
        geom_point(data = ampli, aes(Cycle-1, molecules))+
        #Logistic model:
        geom_line(data = NULL, aes(0:60, res_log,
                                   col = "Logistic"),
                  linewidth = 0.75)+
        #Exponential model:
        geom_line(data = NULL, aes(0:60, res_exp,
                                   col = "Exponential"),
                  linewidth = 0.75)+
        labs(x = "Cycle",
             y = "Estimated number of molecules", 
             col = "Amplification model")+
        theme(legend.justification = c(1, 0),
              legend.position = c(1, 0),
        legend.box.margin=margin(rep(10, 4)))+
  scale_colour_brewer(palette = "Set1")+
  coord_cartesian(xlim = c(0, 50), ylim = c(1, K))

# ggsave(filename = "Figures/saturation_models.pdf",
#        dpi = 600, units = "mm",
#        width = 150, height = 100, device = "pdf")
```


## Digital droplet PCR (ddPCR) assays

### ddPCR data

Dataframe summary_experiment contains all info concerning the concentration assays.

```{r open ddpcr data, message = FALSE}
#QuantaSoft output file with additional data (added in data_processing.Rmd)
dataddpcr <- read_csv("data/processed_data/dataddpcr.csv")
# Used columns:
# Sample: Number of the plant sample
# Concentration: Assayed copies/ul in well
# sp: species
# TotalDNA: Total DNA concentration in ddPCR wells, ng/ul

#Open extraction data
#Used columns:
# species name
# Sample: Number of the plant sample
# CDNA_sample: Concentration of total DNA in the sample assayed by Qubit, ng/ul

Vdna_dd <- 5 #Volume of DNA in a well in ul
Vmix_dd <- 20 #Volume of mix in a well in ul

#summary_experiment contains all info concerning the concentration assays
#Molecules_ng is the number of target molecules / ng of total DNA
summary_experiment <- dataddpcr %>% group_by(Sample) %>%
  summarise(sp = sp[1],
            Molecules_ng = mean(Concentration/TotalDNA)) %>%
  left_join(extraction) %>%
  dplyr::select(Sample, species_name, sp, Molecules_ng, CDNA_sample)
```

## Metabarcoding preparation 

DNA concentration in the different communities

### Uniform community (M_U)

```{r dna concentration}
CDNA_U <- 0.5
#Total DNA concentration in ng/ul for all plants
#in the U community (concentration in sample, not in pcr mix)
C_species_ref <- CDNA_U/13 #concentration of each species, ng/ul

summary_experiment <- summary_experiment %>%
  mutate(Volume_equi = max(Molecules_ng)/Molecules_ng,#Volume to take to be as concentrated as 1 ul of Ptr 6 (most concentrated
         cDNA_U = C_species_ref*Volume_equi,
         #Concentration of total DNA to use in the U commu
         molecules_U = cDNA_U*Molecules_ng, #Molecules/ul in sample
         propU = molecules_U/sum(molecules_U),#species proportion
          RankG = 13 - rank(CDNA_sample/Volume_equi) + 1)
```

Number of molecules in the M_U community

```{r commu M_U}
VDNA_metab <- 2 #Volume of DNA used in the mix, ul

#Molecules of each species in mix
summary_experiment %>% dplyr::select(species_name, molecules_U) %>%
  mutate(molecules_mix = VDNA_metab*molecules_U)

VDNA_metab * sum(summary_experiment$molecules_U) #Total number of molecules
```

### "Uniform in Total DNA" Communauty (M_T)

Number of molecules in the M_T community

```{r commu M_T}
summary_experiment <- summary_experiment %>%
  mutate(molecules_T = C_species_ref*Molecules_ng, #molecules/ul of sample
         propT = molecules_T/sum(molecules_T)) #species proportions

#Molecules of each species in mix
summary_experiment %>% dplyr::select(species_name, molecules_T) %>%
  mutate(molecules_mix = VDNA_metab*molecules_T)

VDNA_metab * sum(summary_experiment$molecules_T) #total number of molecules

```

### Geometric community (M_G)

Number of molecules in the M_G community (2-fold dilution)

```{r commu M_G}
summary_experiment <- summary_experiment %>%
  mutate(Volume_equi = max(Molecules_ng)/Molecules_ng,
         cDNA_G = CDNA_U/2^RankG*Volume_equi,
         molecules_G = cDNA_G*Molecules_ng,
         propG = molecules_G/sum(molecules_G))

#Molecules of each species in mix
summary_experiment %>% dplyr::select(species_name, molecules_G) %>%
  mutate(molecules_mix = VDNA_metab*molecules_G)

sum(summary_experiment$molecules_G) * VDNA_metab #Total number of molecules
```

Choice of the order of the species in the Figures

```{r species order}
order_sp <- summary_experiment %>%
  dplyr::select(species_name, RankG) %>%
  arrange(-RankG) %>%
  pull(species_name)
```


## Figure 3: ddPCR assays

Target DNA concentrations of each sample

```{r ddpcr analysis, message = FALSE}

#Open ddpcr data for figure 3
data_dd_fig <- dataddpcr %>%
  left_join(summary_experiment %>% dplyr::select(sp, species_name, RankG))

#Rank of the species
order_short <- summary_experiment %>% dplyr::select(sp, RankG) %>%
  arrange(-RankG) %>% pull(sp)

highlight <- function(x, pat, color="black", family="") {
  ifelse(grepl(pat, x), glue("<b style='font-family:{family}; color:{color}'>{x}</b>"), x)
}

ggplot(data_dd_fig)+
  #Replicates values:
  geom_point(aes(factor(sp, levels = order_short, ordered = T),
                 Concentration_copies_ng/1000,
                 shape = as.factor(TotalDNA)))+
  #Median values:
  geom_point(data = summary_experiment,
             aes(as.factor(sp), Molecules_ng/1000),
             fill = "red", shape = 23, size = 3)+
  labs(x = "Plant species",
       y = "Thousands of molecules per ng of total DNA\n",
       shape = TeX("Concentration (ng/$\\mu l$)"))+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))+
  theme(axis.text.x=element_markdown(),
        legend.title.align=0.5,
        legend.text.align = 0.5)

# ggsave(filename = "Figures/ddpcr_fig.pdf",
#        dpi = 600, units = "mm",
#        width = 150, height = 100, device = "pdf")

```

Statistics from ddPCR assays:

Species Populus tremula and Rhododendron ferrugineum

Number of copies/ng of total DNA for the two extreme species.

```{r stats ddpcr}
#Populus tremula
data_dd_fig %>% filter(sp == "Ptr") %>%
  pull(Concentration_copies_ng) %>% summary

data_dd_fig %>% filter(sp == "Ptr") %>%
  pull(Concentration_copies_ng) %>% sd

#Rhododendron ferrugineum
data_dd_fig %>% filter(sp == "Rfe") %>%
  pull(Concentration_copies_ng) %>% summary

data_dd_fig %>% filter(sp == "Rfe") %>%
  pull(Concentration_copies_ng) %>% sd

summary_experiment$Molecules_ng %>% summary
```


## Metabarcoding results

Pipeline from raw fastq data: see data_processing.Rmd file (we used the obitools softwares).

Open data, filter bad PCR replicates:

```{r open metabarcoding data, message = FALSE}
df_Sper01 <- read_csv("data/processed_data/df_Sper01.csv")

#Summarising all information for each sample:
summary_sample <- df_Sper01 %>%
  group_by(Sample) %>%
  summarise(total_count_sample = sum(reads),
            NegControl = NegControl[1],
            Spike_level = Spike_level[1],
            Community = Community[1]) %>%
  arrange(total_count_sample)

#Number of reads by sample:
summary(summary_sample$total_count_sample)

#Same without negative controls:
summary(summary_sample %>%
          filter(!NegControl) %>% pull(total_count_sample))

#Std of number of reads by sample:
sd(summary_sample %>%
          filter(!NegControl) %>% pull(total_count_sample))

#Replicates with less than 5000 reads are removed
reads_threshold <- 5000 

#Plotting all the PCR samples
ggplot(summary_sample %>%
          filter(!NegControl))+
  geom_point(aes(x = 1:nrow(summary_sample %>%
          filter(!NegControl)),
                 y = total_count_sample,
                 shape = Community))+
  labs(x = "Sample ordered by total number of reads",
       y = "Total number of reads")+
  scale_y_log10()+
  geom_hline(yintercept = reads_threshold)

```

### Data preparation

Observed and expected proportions in final composition.

#### Community M_U

```{r analysis M_U, message = FALSE}
#df_targetU contains clean data of species abundances in each replicates of the M_U community

df_targetU <- df_Sper01 %>%
  filter(Community == "U" &
           species_name %in% barcodes$species_name &
                          total_count_sample > reads_threshold &
                          !NegControl) %>%
  #observed proportions:
  mutate(prop = obiclean_weight/total_count_sample) %>%
  left_join(summary_experiment %>%
              dplyr::select(species_name, sp, propU)) %>%
  rename(prop_expected = propU)
```

#### Community M_T

```{r analysis M_T, message = FALSE}
#df_targetT contains clean data of species abundances in each replicates of the M_T community

df_targetT <- df_Sper01 %>%
  filter(Community == "T" &
           species_name %in% barcodes$species_name &
           total_count_sample > reads_threshold &
           !NegControl) %>%
  #observed proportions:
  mutate(prop = obiclean_weight/total_count_sample) %>%
  left_join(summary_experiment %>%
              dplyr::select(species_name, sp, propT)) %>%
  rename(prop_expected = propT)
```

#### Community M_G

```{r analysis M_G, message = FALSE}
#df_targetG contains clean data of species abundances in each replicates of the M_G community

df_targetG <- df_Sper01 %>%
  filter(Community == "G" &
           species_name %in% barcodes$species_name &
           total_count_sample > reads_threshold &
           !NegControl) %>%
  #observed proportions:
  mutate(prop = obiclean_weight/total_count_sample) %>%
  left_join(summary_experiment %>%
              dplyr::select(species_name, sp, propG)) %>%
  rename(prop_expected = propG)
```

### Figure 4: observed and expected proportions

```{r observed proportions}

#Choice of colors for the figures:
colp <- c("Expected" = "gold",
          "Expected\nwithout\nPCR bias" = "gold",
          "Expected\nwithout\nPCR and\nconcentration\nbiases" = "gold")

#M_U community: obs/expected proportions
gobsU <- ggplot(df_targetU)+
  #Observed proportions:
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop))+
  #No PCR bias:
      geom_point(data = summary_experiment,
             aes(sp, 1/nrow(summary_experiment),
                 fill = "Expected\nwithout\nPCR bias"),
             shape = 23,
             size = 3)+
  #No bias:
    geom_hline(aes(yintercept = 1/nrow(summary_experiment),
                col = "Expected\nwithout\nPCR and\nconcentration\nbiases"),
             linetype = "dashed")+
  ggtitle(TeX("Uniform community (${{M}_U}$)"))+
  labs(y = "", x = "", fill = "", col = "")+
  ylim(min(df_targetT$prop), max(df_targetT$prop)) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x=element_markdown(),
        legend.title.align=0.5)+
  scale_color_manual(values = colp)+
  scale_fill_manual(values = colp)+
  scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))
  
#M_T community: obs/expected proportions
gobsT <- ggplot(df_targetT)+
  #Observed proportions:
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   prop))+
  #No PCR bias:
    geom_point(data = summary_experiment,
             aes(sp, propT, fill = "Expected\nwithout\nPCR bias"),
             shape = 23,
             size = 3)+
  #No bias:
  geom_hline(aes(yintercept = 1/nrow(summary_experiment),
                col = "Expected\nwithout\nPCR and\nconcentration\nbiases"),
             linetype = "dashed")+
  ggtitle(TeX("Uniform in Total DNA community (${{M}_T}$)"))+
  labs(y = "", x = "", fill = "", col = "")+
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x=element_markdown(),
        legend.title.align=0.5)+
  scale_color_manual(values = colp)+
  scale_fill_manual(values = colp)+
    scale_x_discrete(labels= function(x) highlight(x, "Cb|Fe"))

#Merge both figures
fig <- ggpubr::ggarrange(gobsU, gobsT,
                  ncol = 1,
                  common.legend = T,
                  legend = "right")
annotate_figure(fig,
                bottom = text_grob("Species"),
                left = text_grob("Observed reads proportions", 
                                 rot = 90))

# ggsave("Figures/metabar_results.pdf", units = "mm",
#        width = 150, height = 200, dpi = 600, device = "pdf")
```

Statistics about the proportions

```{r prop stat}

df_targetU %>%
  group_by(sp) %>%
  summarise(std = sd(prop), mean = mean(prop)) %>%
  arrange(mean)

df_targetT %>%
  group_by(sp) %>%
  summarise(std = sd(prop), mean = mean(prop)) %>%
  arrange(mean)

df_targetG %>%
  group_by(sp) %>%
  summarise(std = sd(prop), mean = mean(prop)) %>%
  arrange(mean)
```

## Ratio correction from a reference mock community (M_U)

This approach considers that the factor bias is independent to the whole community composition.

Correction factor computed from community M_U is:

$$\text{Correction factor: }a_s = \frac{\text{prop}_{obs}(s)}{\text{prop}_{init}(s)} (\times \: \text{constant value})$$
Then:

$$\text{Proportions inferred by ratio method:} \:\: p_s = \frac{\text{prop}_{obs}(s)}{a_s}$$


```{r correction mock, message = FALSE}

#CorrecU computes the correction factor
correcU <- df_targetU %>%
  group_by(species_name) %>%
  summarise(correc = median(prop)/prop_expected[1], sp = sp[1])

#Verifying on the M_U community that correction works
df_targetU <- df_targetU %>% left_join(correcU) %>%
  mutate(prop_infer_ratio = prop/correc) %>%
  group_by(Sample) %>%
  mutate(prop_infer_ratio = prop_infer_ratio/sum(prop_infer_ratio,
                                               na.rm = T)) %>%
  mutate(species_name = factor(species_name, levels = order_sp,
                                  ordered = T))

#Applying correction to M_T
df_targetT <- df_targetT %>% left_join(correcU) %>%
    mutate(prop_infer_ratio = prop/correc) %>%
  group_by(Sample) %>%
  mutate(prop_infer_ratio = prop_infer_ratio/sum(prop_infer_ratio,
                                               na.rm = T)) %>%
  mutate(species_name = factor(species_name, levels = order_sp,
                                  ordered = T))

#Appplying correction to M_G
df_targetG <- df_targetG %>% left_join(correcU) %>%
  mutate(prop_infer_ratio = prop/correc) %>%
  group_by(Sample) %>%
  mutate(prop_infer_ratio = prop_infer_ratio/sum(prop_infer_ratio,
                                               na.rm = T)) %>%
  mutate(species_name = factor(species_name, levels = order_sp,
                                  ordered = T))
```

## Efficiencies inference

### Export data to Julia

Export data to Julia to infer efficiencies and proportions with flimo

The files used are metabar_bias_functions.jl and inference_efficiencies_ps.jl.

```{r export julia, message = FALSE}
#Reads / species / replicates in M_U
readsU <- df_targetU %>%
  dplyr::select(Sample, obiclean_weight, species_name) %>%
  pivot_wider(names_from = species_name,
              values_from = obiclean_weight)%>%
  ungroup %>% dplyr::select(-Sample)

#Initial quantity of molecules in M_U
qty_initU <- left_join(data.frame(species_name = colnames(readsU)),
                       summary_experiment %>%
                       dplyr::select(species_name, molecules_U)) %>%
              pull(molecules_U)*2 #2ul

# write_csv(readsU, "data/export_to_julia/reads_U.csv")
# write_csv(data.frame(qty_initU), "data/export_to_julia/qty_initU.csv")

#Reads / species / replicates in M_T
readsT <- df_targetT %>%
  dplyr::select(Sample, obiclean_weight, species_name) %>%
  pivot_wider(names_from = species_name,
              values_from = obiclean_weight) %>%
  ungroup %>% dplyr::select(-Sample)

#Initial quantity of molecules in M_T
qty_initT <- left_join(data.frame(species_name = colnames(readsU)),
                       summary_experiment %>%
                         dplyr::select(species_name, molecules_T)) %>%
              pull(molecules_T)*2 #2ul

# write_csv(readsT, "data/export_to_julia/reads_T.csv")
# write_csv(data.frame(qty_initT), "data/export_to_julia/qty_initT.csv")

#Reads / species / replicates in M_G
readsG <- df_targetG %>%
  dplyr::select(Sample, obiclean_weight, species_name) %>%
  pivot_wider(names_from = species_name,
              values_from = obiclean_weight,
              values_fill = 0) %>%
  ungroup %>% dplyr::select(-Sample)

#Initial quantity of molecules in M_G
qty_initG <- left_join(data.frame(species_name = colnames(readsU)),
                       summary_experiment %>%
                       dplyr::select(species_name, molecules_G)) %>%
              pull(molecules_G) #2ul

# write_csv(readsG, "data/export_to_julia/reads_G.csv")
# write_csv(data.frame(qty_initG), "data/export_to_julia/qty_initG.csv")
```

### Proportions corrected with PCR efficiencies

Proportions inferred in Julia using PCR efficiencies

Run metabar_bias_functions.jl (functions) and inference_efficiencies_ps.jl (inference of efficiencies from M_U and then proportions in M_T and M_G).

#### Efficiencies

```{r efficiencies M_U Julia, message = FALSE}
#Inferred efficiencies
efficiencies_infer <- cbind(1, #Lambda_RosaCanina
                    read_csv("data/export_to_r/efficiencies_U_K13.csv"))
colnames(efficiencies_infer) <- colnames(readsU)

apply(efficiencies_infer, 2, sd)

#Add efficiencies to summary_experiment
summary_experiment <- summary_experiment %>%
  left_join(efficiencies_infer %>%
              as_tibble() %>%
              pivot_longer(1:13, names_to = "species_name",
                           values_to = "efficiencies") %>%
              group_by(species_name) %>%
              summarise(efficiencies = mean(efficiencies)))
```

#### Inferred proportions in M_T and M_G

Loading inferred proportions computed in Julia

```{r results julia M_T, message = FALSE}
#Species proportions inferred for M_T in Julia
inferT <- read.csv("data/export_to_r/prop_inferT_K13.csv")
colnames(inferT) <- colnames(readsT)

#Show mean proportions and std of proportions for each species
inferT %>%
  pivot_longer(everything(),
               names_to = "species_name",
               values_to = "prop_infer_Lambda") %>%
  group_by(species_name) %>%
  summarise(prop = mean(prop_infer_Lambda),
            sd = sd(prop_infer_Lambda)/prop)

```

```{r results julia M_G, message = FALSE}
#Species proportions inferred for M_G in Julia
inferG <- read.csv("data/export_to_r/prop_inferG_K13.csv")
colnames(inferG) <- colnames(readsG)

#Show mean proportions and std of proportions for each species
inferG %>%
  pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop_infer_Lambda") %>%
              group_by(species_name) %>%
              summarise(prop = mean(prop_infer_Lambda),
                        sd_mean = sd(prop_infer_Lambda)/prop)
```

#### Merge the results

```{r inference results, message = FALSE}

#Raw and Corrected proportions of the different species in M_U
resU <- df_targetU %>%
  group_by(species_name) %>%
  summarise(prop = median(prop),
            prop_expected = prop_expected[1],
            prop_infer_ratio = median(prop_infer_ratio))

#Raw and Corrected proportions of the different species in M_T
resT <- df_targetT %>%
  group_by(species_name) %>%
  summarise(prop = median(prop), #Observed
            prop_expected = prop_expected[1], #Expected
            prop_infer_ratio = median(prop_infer_ratio)) %>% #Corrected by ratio
  left_join(inferT %>% #inferred with Lambda_s
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop_infer_Lambda") %>%
              group_by(species_name) %>%
              summarise(
                prop_infer_Lambda = mean(prop_infer_Lambda))) %>%
  arrange(-dplyr::row_number())

#Raw and Corrected proportions of the different species in M_G
resG <- df_targetG %>%
  group_by(species_name) %>%
  summarise(prop = median(prop),
            prop_expected = prop_expected[1],
            prop_infer_ratio = median(prop_infer_ratio)) %>%
  left_join(inferG %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop_infer_Lambda") %>%
              group_by(species_name) %>%
              summarise(
                prop_infer_Lambda = mean(prop_infer_Lambda))) %>%
  arrange(-dplyr::row_number())
```


## Taqman assay

In this section, efficiencies of 3 species are estimated from a Taqman qPCR assay.

Open data (prepared in data_processing.Rmd)

```{r open taqman}
quantif_taqman <- read.csv(
  "data/processed_data/quantification_taqman.csv")
kinetics <- read.csv("data/processed_data/taqman_kinetics.csv")
```

Plot amplification curves and Ct = f(concentration)

```{r show taqman results}
ggplot(kinetics)+
  geom_line(aes(Cycle, RFU, group = Well, col = probe))

ggplot(quantif_taqman)+
  geom_point(aes(copies_ul, Cq, group = Well, col = probe))+
  #Cq = quantification cycle = Ct = threshold cycle
  scale_x_log10()+
  labs(y="Ct")+
  ggtitle("Ct = f(log(Concentration))")
```

### First step: linear regression

Using the relation Ct = a log(concentration) + b

```{r linear regression taqman}
Vmix_taq <- 25 #ul volume of a well for Taqman qPCR

quantif_taqman$slope <- NA
quantif_taqman$intercept <- NA

#For each probe, compute the regression
for (s in unique(quantif_taqman$probe)){
  reg <- lm(Cq ~ log10(copies),
            quantif_taqman %>%
              filter(probe == s) %>%
              group_by(Dilu) %>%
              summarise(Cq = mean(Cq),
                        copies = Vmix_taq*copies_ul[1]))
  
  quantif_taqman[quantif_taqman$probe == s, "slope"] <- reg$coefficients[2]
  quantif_taqman[
    quantif_taqman$probe == s, "intercept"] <- reg$coefficients[1]
}

#Estimate constants of the model

#Estimated efficiency
quantif_taqman$rate <- 10^(-1/quantif_taqman$slope)-1 

#Estimated number of molecules at C_t
quantif_taqman$Mct <- 10^(-quantif_taqman$intercept/quantif_taqman$slope)

#Show results
quantif_taqman %>% group_by(probe) %>%
  summarise(rate = rate[1],
            Mct = Mct[1]/1e11)

#Compute common Mct for the 3 species
Mct_glob <- quantif_taqman %>%
  group_by(sp) %>%
  summarise(Mct = mean(Mct)) %>% pull(Mct) %>% mean

```

### Computing PCR efficiencies

```{r pcr efficiencies, message = FALSE}

#Computing Lambda from previous estimates
efficiencies <- quantif_taqman %>%
  mutate(Lambda = (Mct_glob/(Vmix_taq*copies_ul))^(1/Cq)-1)

#Show results for each species
ggplot(efficiencies)+
  geom_point(aes(probe, Lambda, col = factor(Dilu)))

#Averaging by probes
efficiencies %>% group_by(probe) %>% summarise(Lambda = mean(Lambda))
#Averaging by species
efficiencies %>% group_by(sp) %>% summarise(Lambda = mean(Lambda))

#Lambdas = efficiencies
efficiencies_taq <- efficiencies %>% group_by(sp) %>%
  summarise(efficiency = mean(Lambda),
            sdeff = sd(Lambda))

quantif_taqman <- quantif_taqman %>% left_join(efficiencies_taq)

```

### Observed amplification bias for these 3 species

Comparing the 3 species from the M_U community (amplified within the 13 species pool)

```{r prop commu 3 species}

ggplot(df_targetU %>%
  filter(species_name %in% c("Capsella_bursa-pastoris",
                             "Carpinus_betulus",
                             "Fraxinus_excelsior")))+
  geom_boxplot(aes(species_name, prop))+
  labs(x = "Species", y = "Proportions in M_U")+
  theme(axis.text.x = element_text(angle = 90))
                   
#Renormalized ps for the 3 species from M_U
df_targetU %>%
  filter(species_name %in% c("Capsella_bursa-pastoris",
                             "Carpinus_betulus",
                             "Fraxinus_excelsior")) %>%
  group_by(species_name) %>%
  summarise(prop = mean(prop)) %>% mutate(prop = prop/sum(prop))

```

## Table 2: Amplification efficiencies and proportions in M_U

Summarising previous information

```{r table2}
#Proportions observed and expected in M_U
resU %>% dplyr::select(species_name, prop_expected, prop)

#Efficiencies estimated by Taqman
efficiencies_taq
#Normalized efficiencies from Taqman
Lambda_Fex <- summary_experiment %>% filter(sp == "Fex") %>% pull(efficiencies)

efficiencies %>% group_by(probe) %>%
    summarise(efficiency = mean(Lambda),
              sdeff = sd(Lambda)) %>%
  #Divide Lambda_s so that Lambda_Fex inferred by flimo = Lambda_Fex taqman
  mutate(efficiency = efficiency/efficiencies_taq$efficiency[3]*Lambda_Fex, 
         sdeff = sdeff/efficiencies_taq$efficiency[3]*Lambda_Fex)

#Efficiencies estimated with flimo
summary_experiment %>% arrange(RankG) %>%
  dplyr::select(species_name, efficiencies)
```


## Table 3: proportions in M_T and M_G

Inferred proportions in M_T and M_G

### Proportions

Inferred with the ratio method or the new approach in this paper

```{r Table 3}
resT
resG
```

### Proportions with exponential model

Computation of neff for M_U (number of effective exponential cycles) with the truncated exponential model


```{r prop exponential, message = FALSE}

#Combine data in summary_experiment
summary_experiment <- summary_experiment %>%
  left_join(resU %>% dplyr::select(species_name, prop) %>%
                  rename(prop_obsU = prop)) %>%
  left_join(resT %>% dplyr::select(species_name, prop) %>%
              rename(prop_obsT = prop)) %>%
  left_join(resG %>% dplyr::select(species_name, prop) %>%
              rename(prop_obsG = prop))

#mg stands for Geometric Mean

#Geometric Mean of Lambda_s + 1
mg_lam_s_p1 <- exp(mean(log(summary_experiment$efficiencies+1))) 

#M_U
#Geometric Mean of relative abundances ps
mg_psU <- exp(mean(log(summary_experiment$prop_obsU))) 

#Geometric Mean of initial numbers of molecules m0s
mg_m0sU <- exp(mean(log(VDNA_metab*summary_experiment$molecules_U))) #molecules/ug

#Number of effective exponential cycle for M_U
neffU <- (log(mg_psU)+log(K)-log(mg_m0sU))/log(mg_lam_s_p1)

#M_T

mg_psT <- exp(mean(log(summary_experiment$prop_obsT)))
mg_m0sT <- exp(mean(log(VDNA_metab*summary_experiment$molecules_T))) #molecules/ug
neffT <- (log(mg_psT)+log(K)-log(mg_m0sT))/log(mg_lam_s_p1)

#M_G

mg_psG <- exp(mean(log(summary_experiment$prop_obsG)))
mg_m0sG <- exp(mean(log(VDNA_metab*summary_experiment$molecules_G))) #molecules/ug
neffG <- (log(mg_psG)+log(K)-log(mg_m0sG))/log(mg_lam_s_p1)

#As neff is unknown in practice, what are the inferred proportions for different choosen value of neff ?
Cycles <- 1:40
res_exp <- NULL
for (cyc in Cycles){ #Considering cyc as neff
    m0s <- summary_experiment$prop_obsU/
      (1+summary_experiment$efficiencies)^cyc
  psU <- m0s/sum(m0s)
  
      m0s <- summary_experiment$prop_obsT/
        (1+summary_experiment$efficiencies)^cyc
  psT <- m0s/sum(m0s)
  
      m0s <- summary_experiment$prop_obsG/
        (1+summary_experiment$efficiencies)^cyc
  psG <- m0s/sum(m0s)
  
  res_exp <- rbind(res_exp,
                   data.frame(sp = summary_experiment$sp,
                              cycle = cyc,
                              psU = psU, psT = psT, psG = psG))

}

#Proportions (with exponential model) in M_U for different values of neff
ggplot(res_exp)+
  geom_line(aes(cycle, psU, col = sp))+
  geom_hline(yintercept = 1/13)+
  geom_vline(xintercept = neffU)+
  ggtitle("Proportions in M_U for different values of neff")

#Proportions (with exponential model) in M_T for different values of neff
ggplot(res_exp)+
  geom_line(aes(cycle, psT, col = sp))+
  ggtitle("Proportions in M_T for different values of neff")

#Proportions(with exponential model)  in M_G for different values of neff
ggplot(res_exp)+
  geom_line(aes(cycle, psG, col = sp))+
  ggtitle("Proportions in M_G for different values of neff")

```


### Estimation error: RMSE values

RMSE (root mean squared error) to compare observed/corrected vs expected proportions
Either absolute or relative error

```{r rmse}
#Absolute Error
AbsErr <- function(p_observed, p_expected){
  sqrt(sum((p_observed-p_expected)^2)/length(p_observed))
}

#Relative Error
RelErr <- function(p_observed, p_expected){
  sqrt(sum(((p_observed-p_expected)/p_expected)^2)/length(p_observed))
}

#M_U
summary(resU$prop)

AbsErr(resU$prop, resU$prop_expected)
RelErr(resU$prop, resU$prop_expected)

#M_T
summary(resT$prop)

AbsErr(resT$prop, resT$prop_expected)
AbsErr(resT$prop_infer_ratio, resT$prop_expected)
AbsErr(resT$prop_infer_Lambda, resT$prop_expected)

RelErr(resT$prop, resT$prop_expected)
RelErr(resT$prop_infer_ratio, resT$prop_expected)
RelErr(resT$prop_infer_Lambda, resT$prop_expected)

#RMSE of T if it is considered as a uniform community
AbsErr(resT$prop, resU$prop_expected)
RelErr(resT$prop, resU$prop_expected)

#M_G
summary(resG$prop)

AbsErr(resG$prop, resG$prop_expected)
AbsErr(resG$prop_infer_ratio, resG$prop_expected)
AbsErr(resG$prop_infer_Lambda, resG$prop_expected)

RelErr(resG$prop, resG$prop_expected)
RelErr(resG$prop_infer_ratio, resG$prop_expected)
RelErr(resG$prop_infer_Lambda, resG$prop_expected)
```

Inference at neffU : if the amplification is exponential and is stopped after neffU cycles, the estimated proportions are psU, psT and psG (below). Associated RMSE.

```{r inference neffU}

m0s <- summary_experiment$prop_obsU/
  (1+summary_experiment$efficiencies)^neffU
psU <- m0s/sum(m0s)
  
m0s <- summary_experiment$prop_obsT/
  (1+summary_experiment$efficiencies)^neffU
psT <- m0s/sum(m0s)
  
m0s <- summary_experiment$prop_obsG/
  (1+summary_experiment$efficiencies)^neffU
psG <- m0s/sum(m0s)

AbsErr(psU, summary_experiment$propU)
RelErr(psU, summary_experiment$propU)

AbsErr(psT, summary_experiment$propT)
RelErr(psT, summary_experiment$propT)

AbsErr(psG, summary_experiment$propG)
RelErr(psG, summary_experiment$propG)

```

###Associated biodiversity measures: Hill numbers

Computing the Hill numbers to evaluate the influence of correction on ecological conclusions.

```{r}
#Hill numbers
D <- function(ps, q){
  ps <- ps/sum(ps)
  ps <- ps[ps>0]
  ifelse(q == 1, exp(-sum(ps*log(ps))), sum(ps^q)^(1/(1-q)))
}

#M_T

D(resT$prop_expected, 1)
D(resT$prop, 1)
D(resT$prop_infer_ratio, 1)
D(resT$prop_infer_Lambda, 1)

D(resT$prop_expected, 2)
D(resT$prop, 2)
D(resT$prop_infer_ratio, 2)
D(resT$prop_infer_Lambda, 2)

#M_G

D(resG$prop_expected, 1)
D(resG$prop, 1)
D(resG$prop_infer_ratio, 1)
D(resG$prop_infer_Lambda, 1)

D(resG$prop_expected, 2)
D(resG$prop, 2)
D(resG$prop_infer_ratio, 2)
D(resG$prop_infer_Lambda, 2)
```

## Figure 5: Simulations: impact of efficiency variations

Simulated amplification to quantify the effect of efficiency differences.

### Preparing simulations

pcr_sim : Function to simulate PCR with multiple species

```{r simu pcr multi species, message = FALSE}
pcr_sim <- function(m0=1,
                    lambda=rep(1, length(m0)),
                    K=1e13,
                    cycles = 40,
                    delta = 1) { #for initial overdispersion
  param <- data.frame(m0 = m0,
                      lambda = lambda)
  nspecies <- nrow(param)
  
  #Number of molecules at each cycle for each species
  kinetics <- matrix(0, nrow = cycles+1, ncol = nspecies)
  if (delta <= 1){ #Initial variab = Poisson
    for (m in 1:nspecies){
      kinetics[1,m] <- rpois(1, m0[m])
    }
  } else { #Overdispersed: NegBin
    for (m in 1:nspecies){
      kinetics[1,m] <- rnbinom(1, m0[m]/delta, 1/delta)
    }
  }
  for (cyc in 2:(1+cycles)) {
    charge <- sum(kinetics[cyc-1,]-kinetics[1,])/K
    for (m in 1:nspecies) {
      lam <- lambda[m]
      mc <- kinetics[cyc-1,m] #Molecules of s at previous cycle
      lam <- max(0, lam*(1-charge))
      #Number of created molecules
      nb <- rbinom(1, mc, lam)
      kinetics[cyc,m] <- kinetics[cyc-1,m]+nb
    }
  }
  return(kinetics)
}

nspecies <- 2
M0 = rep(2.5e5/nspecies, nspecies) #Total number of molecules: 2.5e5

#Tested values
lam1 <- 1 #Efficiency of species 1 Rosa Canina
Lam2 <- seq(0.8, 1, by = 0.001) #Different efficiencies of species 2

#Results of the simulated PCR
res <- NULL
for (lam2 in Lam2){
  p <- pcr_sim(m0=M0, lambda=c(lam1, lam2), K=K)
  res <- rbind(res, p[41,])
}

#Proportions of the 2 species
prop2 <- df_targetU %>%
  group_by(sp) %>%
  summarise(propU = median(prop)) %>%
  ungroup() %>%
  mutate(propU = propU/(propU+propU[11])) %>% #11 = Rca
  left_join(summary_experiment %>%
              dplyr::select(sp, efficiencies)) %>%
  mutate(deff = 1-efficiencies) %>%
  filter(sp != "Rc")

```

Figure 5:

```{r simu pcr multi species : figure 5}
#Labels positions
prop2$labelx <- prop2$deff - 0.0021
prop2[prop2$sp == "Rfe","labelx"] <- prop2[prop2$sp == "Rfe","labelx"]+
  0.0042
prop2[prop2$sp == "Lco","labelx"] <- prop2[prop2$sp == "Lco","labelx"]+
  0.0042
prop2[prop2$sp == "Lxy","labelx"] <- prop2[prop2$sp == "Lxy","labelx"]+
  0.0042
prop2[prop2$sp == "Aal","labelx"] <- prop2[prop2$sp == "Aal","labelx"]+
  0.0038
prop2[prop2$sp == "Bme","labelx"] <- prop2[prop2$sp == "Bme","labelx"]+
  0.0037
prop2[prop2$sp == "Cbe","labelx"] <- prop2[prop2$sp == "Cbe","labelx"]+
  0.0021


ggplot()+
    geom_vline(data = prop2 %>% filter(sp != "Rca"),
               aes(xintercept = deff), col = "grey80")+
    geom_line(aes(1-Lam2/lam1, res[,1]/(rowSums(res)),
                  col = "Rosa canina"))+
  geom_line(aes(1-Lam2/lam1, res[,2]/(rowSums(res)), col = "other"))+
  geom_hline(yintercept = 0.5, linetype = "dashed")+
  geom_point(data = prop2 %>% filter(sp != "Rca"),
             aes(deff, propU, col = "other"))+
  geom_point(data = prop2 %>% filter(sp != "Rca"),
             aes(deff, 1-propU, col = "Rosa canina"))+
  geom_text(aes(0.135, 0.73, label = "Rosa canina",
                col = "Rosa canina"), size = 4)+
  geom_text(aes(0.135, 0.27,
                label = "Second species", col = "other"), size = 4)+
  geom_text(data = prop2 %>%
              filter(sp != "Rca") %>% arrange(efficiencies),
              aes(labelx, 1, label = sp),
            col = "grey50", size = 3, angle = 90)+
    geom_text(data = prop2 %>%
                filter(sp %in% c("Cbe", "Cbp", "Fex")) %>%
                arrange(efficiencies),
              aes(labelx, 1, label = sp),
            col = "grey25", size = 3, angle = 90)+
  labs(x = "Relative decrease of PCR efficiency compared to Rosa canina",
       y = "Final relative abundances", col = "Species")+
  coord_cartesian(xlim = c(0.006, 0.15), ylim = c(0,1))+
  theme(legend.position = "none")+
  scale_colour_brewer(palette = "Set1")

# ggsave(filename = "Figures/simu_efficiencies.pdf", units = "mm",
#        height = 100, width = 150, device = "pdf", dpi = 600)

```

## Impact of uncertainty on K

Import all the results from Julia where Lambda_s and proportions were inferred with different values of K ranging from 10^11 to 10^14.

```{r open lambda data, message = FALSE}

#K = 1.2 10^14
efficiencies_inferK14 <- cbind(1,
                    read_csv("data/export_to_r/efficiencies_U_K14.csv"))
colnames(efficiencies_inferK14) <- colnames(readsU)
efficiencies_inferK14 <- efficiencies_inferK14 %>%
              as_tibble() %>%
              pivot_longer(1:13, names_to = "species_name",
                           values_to = "efficiencies")
efficiencies_inferK14$K <- K*10

#K = 1.2 10^12
efficiencies_inferK12 <- cbind(1,
                    read_csv("data/export_to_r/efficiencies_U_K12.csv"))
colnames(efficiencies_inferK12) <- colnames(readsU)
efficiencies_inferK12 <- efficiencies_inferK12 %>%
              as_tibble() %>%
              pivot_longer(1:13, names_to = "species_name",
                           values_to = "efficiencies")
efficiencies_inferK12$K <- K/10

#K = 1.2 10^11
efficiencies_inferK11 <- cbind(1,
                            read_csv("data/export_to_r/efficiencies_U_K11.csv"))
colnames(efficiencies_inferK11) <- colnames(readsU)
efficiencies_inferK11 <- efficiencies_inferK11 %>%
              as_tibble() %>%
              pivot_longer(1:13, names_to = "species_name",
                           values_to = "efficiencies")
efficiencies_inferK11$K <- K/100

#K = 1.2 10^13
efficiencies_inferK13 <- efficiencies_infer %>%
              as_tibble() %>%
              pivot_longer(1:13, names_to = "species_name",
                           values_to = "efficiencies")
efficiencies_inferK13$K <- K

#Merged results for supp fig 1
eff_infer_sf1 <- rbind(efficiencies_inferK14,
                       efficiencies_inferK13,
                       efficiencies_inferK12,
                       efficiencies_inferK11) %>%
  left_join(summary_experiment[,2:3])
```

### Supplementary Figure 1

Lambda_s = f(K)

```{r open suppl fig 1, message = FALSE}
eff_infer_sf1 <- eff_infer_sf1 %>%
         filter(species_name != "Rosa_canina")

ggplot(eff_infer_sf1 %>%
         group_by(sp, K) %>%
         summarise(efficiencies = mean(efficiencies)))+
  geom_point(aes(K, efficiencies, col = sp, group = sp))+
  geom_line(aes(K, efficiencies, col = sp, group = sp),
            linetype = "dashed")+
  geom_vline(xintercept = K, linetype = "dashed")+
  scale_x_log10()+
  labs(y = TeX("Efficiencies $\\Lambda_s$"), col = "Species")+
    theme(
        legend.title.align=0.5,
        legend.text.align = 0.5)

# ggsave(filename = "Figures/Lambda_fctK.pdf",
#        dpi = 600, units = "mm",
#        width = 150, height = 100, device = "pdf")
```

Normalising by Lambda_min :

```{r suppl fig 1bis, message = FALSE}
eff_infer_sf1 <- eff_infer_sf1 %>%
  left_join(eff_infer_sf1 %>%
              filter(sp == "Gro") %>%
              dplyr::select(K, efficiencies) %>%
  rename(lambda_min = efficiencies))

ggplot(eff_infer_sf1 %>%
         filter(species_name != "Rosa_canina" & K > 1e11) %>%
         group_by(sp, K) %>%
         summarise(efficiencies = mean(efficiencies),
                   lambda_min = lambda_min[1]))+
  geom_point(aes(K, efficiencies/lambda_min, col = sp, group = sp))+
  geom_line(aes(K, efficiencies/lambda_min, col = sp, group = sp),
            linetype = "dashed")+
  geom_vline(xintercept = K, linetype = "dashed")+
  scale_x_log10()+
  labs(y = TeX("Efficiencies $\\Lambda_s / \\Lambda_{Gro}$"),
       col = "Species")+
    theme(
        legend.title.align=0.5,
        legend.text.align = 0.5)

# ggsave(filename = "Figures/Lambda_Lmin_fctK.pdf",
#        dpi = 600, units = "mm",
#        width = 150, height = 100, device = "pdf")
```

## Supplementary Figure 2

Open inference results for MT

```{r open M_T data, message = FALSE}

inferT15 <- read.csv("data/export_to_r/prop_inferT_K15.csv") #***
colnames(inferT15) <- colnames(readsT)
inferT15 <- inferT15 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferT15$K <- K*100
inferT15$type <- "K 10^15"

inferT14 <- read.csv("data/export_to_r/prop_inferT_K14.csv")
colnames(inferT14) <- colnames(readsT)
inferT14 <- inferT14 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferT14$K <- K*10
inferT14$type <- "K 10^14"

inferT13 <- read.csv("data/export_to_r/prop_inferT_K13.csv")
colnames(inferT13) <- colnames(readsT)
inferT13 <- inferT13 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferT13$K <- K
inferT13$type <- "K 10^13"

inferT12 <- read.csv("data/export_to_r/prop_inferT_K12.csv")
colnames(inferT12) <- colnames(readsT)
inferT12 <- inferT12 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferT12$K <- K/10
inferT12$type <- "K 10^12"

inferT11 <- read.csv("data/export_to_r/prop_inferT_K11.csv")
colnames(inferT11) <- colnames(readsT)
inferT11 <- inferT11 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferT11$K <- K/100
inferT11$type <- "K 10^11"

inferTK <- rbind(inferT15, inferT14, inferT13, inferT12, inferT11)
inferTK <- inferTK %>% left_join(summary_experiment[,2:3])
#add species short names

#Average proportions
inferTK <- inferTK %>% group_by(sp, type) %>%
  summarise(species_name = species_name[1],
            prop = mean(prop))

# write.csv(inferTK, "data/inferTK.csv")

#Observed proportions
inferTK <- rbind(inferTK,
                 resT %>% dplyr::select(species_name, prop) %>%
  left_join(summary_experiment %>% dplyr::select(species_name, sp)) %>%
  rename(prop = prop) %>% mutate(type = "Observed"))

#Theoretical proportions
inferTK <- rbind(inferTK,
                 resT %>% dplyr::select(species_name, prop_expected) %>%
  left_join(summary_experiment %>% dplyr::select(species_name, sp)) %>%
  rename(prop = prop_expected) %>% mutate(type = "Theoretical"))

#Proportions corrected by ratio
inferTK <- rbind(inferTK,
                resT %>% dplyr::select(species_name, prop_infer_ratio) %>%
  left_join(summary_experiment %>% dplyr::select(species_name, sp)) %>%
  rename(prop = prop_infer_ratio) %>% mutate(type = "Ratio"))

```

Open inference results for MG

```{r open M_G data, message = FALSE}

inferG15 <- read.csv("data/export_to_r/prop_inferG_K15.csv") #***
colnames(inferG15) <- colnames(readsG)
inferG15 <- inferG15 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferG15$K <- K*100
inferG15$type <- "K 10^15"

inferG14 <- read.csv("data/export_to_r/prop_inferG_K14.csv")
colnames(inferG14) <- colnames(readsG)
inferG14 <- inferG14 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferG14$K <- K*10
inferG14$type <- "K 10^14"

inferG13 <- read.csv("data/export_to_r/prop_inferG_K13.csv")
colnames(inferG13) <- colnames(readsG)
inferG13 <- inferG13 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferG13$K <- K
inferG13$type <- "K 10^13"

inferG12 <- read.csv("data/export_to_r/prop_inferG_K12.csv")
colnames(inferG12) <- colnames(readsG)
inferG12 <- inferG12 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferG12$K <- K/10
inferG12$type <- "K 10^12"

inferG11 <- read.csv("data/export_to_r/prop_inferG_K11.csv")
colnames(inferG11) <- colnames(readsG)
inferG11 <- inferG11 %>%
              pivot_longer(everything(),
                           names_to = "species_name",
                           values_to = "prop") %>%
  arrange(-dplyr::row_number())
inferG11$K <- K/100
inferG11$type <- "K 10^11"

inferGK <- rbind(inferG15, inferG14, inferG13, inferG12, inferG11)
inferGK <- inferGK %>% left_join(summary_experiment[,2:3]) #add short names

#average proportions
inferGK <- inferGK %>% group_by(sp, type) %>%
  summarise(species_name = species_name[1],
            prop = mean(prop))

# write.csv(inferGK, "data/inferGK.csv")

#Observed proportions
inferGK <- rbind(inferGK,
                 resG %>% dplyr::select(species_name, prop) %>%
  left_join(summary_experiment %>% dplyr::select(species_name, sp)) %>%
  rename(prop = prop) %>% mutate(type = "Observed"))

#Expected proportions
inferGK <- rbind(inferGK,
                 resG %>% dplyr::select(species_name, prop_expected) %>%
  left_join(summary_experiment %>% dplyr::select(species_name, sp)) %>%
  rename(prop = prop_expected) %>% mutate(type = "Theoretical"))

#Proportions corrected by ratio
inferGK <- rbind(inferGK,
                resG %>% dplyr::select(species_name, prop_infer_ratio) %>%
  left_join(summary_experiment %>% dplyr::select(species_name, sp)) %>%
  rename(prop = prop_infer_ratio) %>% mutate(type = "Ratio"))

```

Barplots for the two communities

```{r suppl fig 2}

order_type <- c("Theoretical", "K 10^11", "K 10^12", "K 10^13","K 10^14","K 10^15", "Ratio", "Observed")

gTK <- ggplot(inferTK)+
  geom_col(aes(x = factor(type, levels = order_type, ordered = T),
               y = prop,
               fill = factor(sp, levels = order_short, ordered = T)),
        position = "fill")+
  scale_fill_manual(values=hue_pal()(13))+
  ggtitle(TeX("Uniform in Total DNA community (${{M}_T}$)"))+
  labs(x = "", y = "", fill = "Species")+
  theme(legend.title = element_text(hjust = 0.5),
    plot.title = element_text(hjust = 0.5),
    axis.text.x=element_markdown())

# ggsave(filename = "Figures/commu_K_MT.pdf",
#        dpi = 600, units = "mm",
#        width = 150, height = 180, device = "pdf")

gGK <- ggplot(inferGK)+
  geom_col(aes(x = factor(type, levels = order_type, ordered = T),
               y = prop,
               fill = factor(sp, levels = (order_short), ordered = T)),
        position = "fill")+
  scale_fill_manual(values=hue_pal()(13))+
  ggtitle(TeX("Geometric community (${{M}_G}$)"))+
  # scale_y_log10()+
  labs(x="", y="", fill = "Species")+
  theme(legend.title = element_text(hjust = 0.5),
    plot.title = element_text(hjust = 0.5),
    axis.text.x=element_markdown())

# ggsave(filename = "Figures/commu_K_MG.pdf",
#        dpi = 600, units = "mm",
#        width = 150, height = 180, device = "pdf")


#Merge both figures
fig <- ggpubr::ggarrange(gTK, gGK,
                  ncol = 1,
                  common.legend = T,
                  legend = "right")
annotate_figure(fig,
                bottom = text_grob("Type of proportions"),
                left = text_grob("Species proportions", 
                                 rot = 90))

# ggsave("Figures/resultsK.pdf", units = "mm",
#        width = 180, height = 200, dpi = 600, device = "pdf")

```

## Supplementary Table 1: C-values

Mass of one genome for the 13 species.

```{r 1cvalues}
summary_experiment$Cvalue <- c(0.46, 0.45, 1.03, 0.84, 0.70, 17.29,
                               1.02, 6.35, 1.40, 0.40, 1.76, 0.74, 0.87)

summary_experiment <- summary_experiment %>%
  mutate(copies_genome = Molecules_ng*1e9*Cvalue*1e-12)

summary_experiment
```


## Supplementary Table 2: initial communities composition

```{r sup table 2}
summary_experiment %>% arrange(RankG)
```

## Simulations of mock communities (Supp Fig 3)

100 simulated communities for each of the 3 M0tot values with 13 species

###Varying initial quantity, final abundances

The initial number of molecules varies in the M_U community:

```{r MU changing M0, message = FALSE}

#Different values of total number of molecules at the beginning
M0tot <- 2.5e5*c(1e-1, 1, 1e1)

#Number of simulated communities
nsim <- 100

#save simulations
compo <- NULL

for (sim in 1:nsim){
  for (m0tot in M0tot){
    #Composition of this community
    MU_varM0 <- pcr_sim(m0=rep(m0tot/nrow(summary_experiment),
                           nrow(summary_experiment)),
                    lambda=summary_experiment$efficiencies,
                    K=K,
                cycles = ncycles)
    compo <- rbind(compo, data.frame(sim = sim,
                                   M0tot = m0tot,
                                   sp = summary_experiment$sp,
                                   ps = MU_varM0[nrow(MU_varM0),]/
                                     sum(MU_varM0[nrow(MU_varM0),])))
  }
}

#Plot proportions of the 2 extreme species according to M0tot
ggplot(compo %>% filter(sp %in% c("Rca", "Gro")))+
  geom_boxplot(aes(factor(M0tot), ps, col = sp))+
  geom_point(data = data.frame(),
             aes(factor(M0tot[2]),
                 (summary_experiment %>%
                    filter(sp %in% c("Rca", "Gro")) %>% pull(propU))),
  shape = 23, fill = "gold")+
  scale_color_brewer(palette = "Set1")
#adjust positions for real proportions...

#Detailed values
compo %>% filter(sp %in% c("Rca", "Gro")) %>% group_by(M0tot, sp) %>%
  summarise(mps = mean(ps))

```

### Varying initial quantities, inferred abundances

Data are generated with the logistic model.
Corrections are brought with our approach and with the ratio method (assuming exponential model)

#### Simulate communities

```{r Ratio method, message = FALSE}
#Reference community is simulated with M0tot = 2.5e5 as in the study
compo_ref <- compo %>%
  filter(M0tot == 2.5e5) %>%
  group_by(sp) %>%
  summarise(med_ps = median(ps)) %>%
  mutate(correc = med_ps/(1/nrow(summary_experiment)))
#observed ps/expected ps
#with expected ps = 1/13

#Ratio method to correc proportions
compo <- compo %>%
  left_join(summary_experiment[,c("sp", "species_name")]) %>%
  left_join(compo_ref) %>%
  mutate(ps_ratio = ps/correc) #correcting
  
compo <- compo %>%
  left_join(compo %>% group_by(sim, M0tot) %>%
      summarise(sum_ps_ratio = sum(ps_ratio)) ) %>% #normalising
  mutate(ps_ratio = ps_ratio/sum_ps_ratio) %>%
  dplyr::select(-sum_ps_ratio)
```

#### Export to Julia (for inference)

Export simulated communities to Julia for inference.

```{r export julia sim commu}
for(i in 1:length(M0tot)){
  m0tot <- M0tot[i]
  mat <- compo %>% filter(M0tot == m0tot) %>%
    dplyr::select(sim, species_name, ps) %>%
    pivot_wider(names_from = species_name, values_from = ps) %>%
    dplyr::select(colnames(readsU)) %>% as.matrix()
  # write.csv(mat, paste0("data/export_to_julia/sim100_m0tot_", i, ".csv"),row.names = F)
}
```

Inference is performed in file inference_simulated_communities.jl

#### Inference results computed in Julia

Import inference results

```{r import julia inference, message = FALSE}

res_commu1 <- read.csv("data/export_to_r/res_commu1.csv")
res_commu2 <- read.csv("data/export_to_r/res_commu2.csv")
res_commu3 <- read.csv("data/export_to_r/res_commu3.csv")

colnames(res_commu1) <- colnames(readsU)
colnames(res_commu2) <- colnames(readsU)
colnames(res_commu3) <- colnames(readsU)

res_commu1 <- res_commu1 %>% as_tibble() %>%
  mutate(sim = 1:100, M0tot = 2.5e4) %>%
  pivot_longer(1:13, names_to = "species_name", values_to = "ps_log") %>%
  left_join(summary_experiment %>% dplyr::select(sp, species_name))

res_commu2 <- res_commu2 %>% as_tibble() %>%
  mutate(sim = 1:100, M0tot = 2.5e5) %>%
  pivot_longer(1:13, names_to = "species_name", values_to = "ps_log") %>%
  left_join(summary_experiment %>% dplyr::select(sp, species_name))

res_commu3 <- res_commu3 %>% as_tibble() %>%
  mutate(sim = 1:100, M0tot = 2.5e6) %>%
  pivot_longer(1:13, names_to = "species_name", values_to = "ps_log") %>%
  left_join(summary_experiment %>% dplyr::select(sp, species_name))

res_infer_log <- rbind(res_commu1, res_commu2, res_commu3)
```

#### Supplementary Figure 3

to compare the two approaches (ratio method and efficiencies inference)

```{r figure comparing two approaches}

ggplot(compo)+
  geom_boxplot(aes(factor(sp, levels = order_short, ordered = T),
                   ps_ratio,
                   group = sp, col = "Ratio"), alpha = 0.1)+
  geom_boxplot(data = res_infer_log, aes(sp, ps_log,
                   group = sp, col = "Logistic model"), alpha = 0.1)+
  geom_point(data = summary_experiment,
             aes(sp, 1/nrow(summary_experiment),
                 fill = "Expected\nwithout\nPCR bias"),
             shape = 23,
             size = 3)+
  facet_wrap(M0tot~., ncol = 1)+
  # scale_color_manual(values = colp)+
  scale_fill_manual(values = colp)+
  labs(x = "Species", y = "Corrected reads proportions",
       fill = "", col = "Correction")+
  scale_color_brewer(palette = "Set1")+
  ggtitle(TeX("$M_0^{{total}}$")) +
  theme(legend.title = element_text(hjust = 0.5),
    plot.title = element_text(hjust = 0.5),
    axis.text.x=element_markdown())+
  scale_x_discrete(labels = function(x) highlight(x, "Cb|Fe"))

# ggsave(filename = "Figures/simu_exp_log.pdf",
#        dpi = 600, units = "mm",
#        width = 150, height = 180, device = "pdf")

```

